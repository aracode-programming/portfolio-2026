{
  "version": 3,
  "sources": ["../../@ark-ui/react/dist/components/carousel/carousel-autoplay-indicator.js", "../../@zag-js/core/node_modules/@zag-js/utils/dist/index.mjs", "../../@zag-js/dom-query/dist/index.mjs", "../../@zag-js/core/dist/index.mjs", "../../@ark-ui/react/dist/components/factory.js", "../../@ark-ui/react/dist/utils/compose-refs.js", "../../@ark-ui/react/node_modules/@zag-js/anatomy/dist/index.mjs", "../../@ark-ui/react/node_modules/@zag-js/utils/dist/index.mjs", "../../@zag-js/scroll-snap/dist/index.mjs", "../../@zag-js/types/dist/index.mjs", "../../@ark-ui/react/node_modules/@zag-js/carousel/dist/index.mjs", "../../@ark-ui/react/dist/components/carousel/carousel.anatomy.js", "../../@ark-ui/react/dist/utils/create-context.js", "../../@ark-ui/react/dist/components/carousel/use-carousel-context.js", "../../@ark-ui/react/dist/components/carousel/carousel-progress-text.js", "../../@ark-ui/react/dist/components/carousel/carousel-autoplay-trigger.js", "../../@zag-js/react/node_modules/@zag-js/utils/dist/index.mjs", "../../@zag-js/react/dist/index.mjs", "../../@ark-ui/react/dist/components/carousel/carousel-context.js", "../../@ark-ui/react/dist/components/carousel/carousel-control.js", "../../@ark-ui/react/dist/components/carousel/carousel-indicator.js", "../../@ark-ui/react/dist/utils/create-split-props.js", "../../@ark-ui/react/dist/components/carousel/carousel-indicator-group.js", "../../@ark-ui/react/dist/components/carousel/carousel-item.js", "../../@ark-ui/react/dist/components/carousel/carousel-item-group.js", "../../@ark-ui/react/dist/components/carousel/carousel-next-trigger.js", "../../@ark-ui/react/dist/components/carousel/carousel-prev-trigger.js", "../../@ark-ui/react/dist/components/carousel/carousel-root.js", "../../@ark-ui/react/dist/components/carousel/use-carousel.js", "../../@ark-ui/react/dist/providers/environment/use-environment-context.js", "../../@ark-ui/react/dist/providers/locale/use-locale-context.js", "../../@ark-ui/react/dist/components/carousel/carousel-root-provider.js", "../../@ark-ui/react/dist/components/carousel/carousel.js"],
  "sourcesContent": ["'use client';\nimport { jsx } from 'react/jsx-runtime';\nimport { forwardRef } from 'react';\nimport { ark } from '../factory.js';\nimport { carouselAnatomy } from './carousel.anatomy.js';\nimport { useCarouselContext } from './use-carousel-context.js';\n\nconst parts = carouselAnatomy.build();\nconst CarouselAutoplayIndicator = forwardRef((props, ref) => {\n  const { children, fallback, ...restProps } = props;\n  const carousel = useCarouselContext();\n  return /* @__PURE__ */ jsx(ark.span, { ref, ...parts.autoplayIndicator.attrs, ...restProps, children: carousel.isPlaying ? children : fallback });\n});\nCarouselAutoplayIndicator.displayName = \"CarouselAutoplayIndicator\";\n\nexport { CarouselAutoplayIndicator };\n", "var __defProp = Object.defineProperty;\nvar __typeError = (msg) => {\n  throw TypeError(msg);\n};\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n\n// src/array.ts\nfunction toArray(v) {\n  if (v == null) return [];\n  return Array.isArray(v) ? v : [v];\n}\nvar fromLength = (length) => Array.from(Array(length).keys());\nvar first = (v) => v[0];\nvar last = (v) => v[v.length - 1];\nvar isEmpty = (v) => v.length === 0;\nvar has = (v, t) => v.indexOf(t) !== -1;\nvar add = (v, ...items) => v.concat(items);\nvar remove = (v, ...items) => v.filter((t) => !items.includes(t));\nvar removeAt = (v, i) => v.filter((_, idx) => idx !== i);\nvar insertAt = (v, i, ...items) => [...v.slice(0, i), ...items, ...v.slice(i)];\nvar uniq = (v) => Array.from(new Set(v));\nvar diff = (a, b) => {\n  const set = new Set(b);\n  return a.filter((t) => !set.has(t));\n};\nvar addOrRemove = (v, item) => has(v, item) ? remove(v, item) : add(v, item);\nfunction clear(v) {\n  while (v.length > 0) v.pop();\n  return v;\n}\nfunction nextIndex(v, idx, opts = {}) {\n  const { step = 1, loop = true } = opts;\n  const next2 = idx + step;\n  const len = v.length;\n  const last2 = len - 1;\n  if (idx === -1) return step > 0 ? 0 : last2;\n  if (next2 < 0) return loop ? last2 : 0;\n  if (next2 >= len) return loop ? 0 : idx > len ? len : idx;\n  return next2;\n}\nfunction next(v, idx, opts = {}) {\n  return v[nextIndex(v, idx, opts)];\n}\nfunction prevIndex(v, idx, opts = {}) {\n  const { step = 1, loop = true } = opts;\n  return nextIndex(v, idx, { step: -step, loop });\n}\nfunction prev(v, index, opts = {}) {\n  return v[prevIndex(v, index, opts)];\n}\nfunction chunk(v, size) {\n  return v.reduce((rows, value, index) => {\n    if (index % size === 0) rows.push([value]);\n    else last(rows)?.push(value);\n    return rows;\n  }, []);\n}\nfunction flatArray(arr) {\n  return arr.reduce((flat, item) => {\n    if (Array.isArray(item)) {\n      return flat.concat(flatArray(item));\n    }\n    return flat.concat(item);\n  }, []);\n}\nfunction partition(arr, fn) {\n  return arr.reduce(\n    ([pass, fail], value) => {\n      if (fn(value)) pass.push(value);\n      else fail.push(value);\n      return [pass, fail];\n    },\n    [[], []]\n  );\n}\n\n// src/equal.ts\nvar isArrayLike = (value) => value?.constructor.name === \"Array\";\nvar isArrayEqual = (a, b) => {\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; i++) {\n    if (!isEqual(a[i], b[i])) return false;\n  }\n  return true;\n};\nvar isEqual = (a, b) => {\n  if (Object.is(a, b)) return true;\n  if (a == null && b != null || a != null && b == null) return false;\n  if (typeof a?.isEqual === \"function\" && typeof b?.isEqual === \"function\") {\n    return a.isEqual(b);\n  }\n  if (typeof a === \"function\" && typeof b === \"function\") {\n    return a.toString() === b.toString();\n  }\n  if (isArrayLike(a) && isArrayLike(b)) {\n    return isArrayEqual(Array.from(a), Array.from(b));\n  }\n  if (!(typeof a === \"object\") || !(typeof b === \"object\")) return false;\n  const keys = Object.keys(b ?? /* @__PURE__ */ Object.create(null));\n  const length = keys.length;\n  for (let i = 0; i < length; i++) {\n    const hasKey = Reflect.has(a, keys[i]);\n    if (!hasKey) return false;\n  }\n  for (let i = 0; i < length; i++) {\n    const key = keys[i];\n    if (!isEqual(a[key], b[key])) return false;\n  }\n  return true;\n};\n\n// src/guard.ts\nvar isDev = () => process.env.NODE_ENV !== \"production\";\nvar isArray = (v) => Array.isArray(v);\nvar isBoolean = (v) => v === true || v === false;\nvar isObjectLike = (v) => v != null && typeof v === \"object\";\nvar isObject = (v) => isObjectLike(v) && !isArray(v);\nvar isNumber = (v) => typeof v === \"number\" && !Number.isNaN(v);\nvar isString = (v) => typeof v === \"string\";\nvar isFunction = (v) => typeof v === \"function\";\nvar isNull = (v) => v == null;\nvar hasProp = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\nvar baseGetTag = (v) => Object.prototype.toString.call(v);\nvar fnToString = Function.prototype.toString;\nvar objectCtorString = fnToString.call(Object);\nvar isPlainObject = (v) => {\n  if (!isObjectLike(v) || baseGetTag(v) != \"[object Object]\" || isFrameworkElement(v)) return false;\n  const proto = Object.getPrototypeOf(v);\n  if (proto === null) return true;\n  const Ctor = hasProp(proto, \"constructor\") && proto.constructor;\n  return typeof Ctor == \"function\" && Ctor instanceof Ctor && fnToString.call(Ctor) == objectCtorString;\n};\nvar isReactElement = (x) => typeof x === \"object\" && x !== null && \"$$typeof\" in x && \"props\" in x;\nvar isVueElement = (x) => typeof x === \"object\" && x !== null && \"__v_isVNode\" in x;\nvar isFrameworkElement = (x) => isReactElement(x) || isVueElement(x);\n\n// src/functions.ts\nvar runIfFn = (v, ...a) => {\n  const res = typeof v === \"function\" ? v(...a) : v;\n  return res ?? void 0;\n};\nvar cast = (v) => v;\nvar identity = (v) => v();\nvar noop = () => {\n};\nvar callAll = (...fns) => (...a) => {\n  fns.forEach(function(fn) {\n    fn?.(...a);\n  });\n};\nvar uuid = /* @__PURE__ */ (() => {\n  let id = 0;\n  return () => {\n    id++;\n    return id.toString(36);\n  };\n})();\nfunction match(key, record, ...args) {\n  if (key in record) {\n    const fn = record[key];\n    return isFunction(fn) ? fn(...args) : fn;\n  }\n  const error = new Error(`No matching key: ${JSON.stringify(key)} in ${JSON.stringify(Object.keys(record))}`);\n  Error.captureStackTrace?.(error, match);\n  throw error;\n}\nvar tryCatch = (fn, fallback) => {\n  try {\n    return fn();\n  } catch (error) {\n    if (error instanceof Error) {\n      Error.captureStackTrace?.(error, tryCatch);\n    }\n    return fallback?.();\n  }\n};\nfunction throttle(fn, wait = 0) {\n  let lastCall = 0;\n  let timeout = null;\n  return ((...args) => {\n    const now = Date.now();\n    const timeSinceLastCall = now - lastCall;\n    if (timeSinceLastCall >= wait) {\n      if (timeout) {\n        clearTimeout(timeout);\n        timeout = null;\n      }\n      fn(...args);\n      lastCall = now;\n    } else if (!timeout) {\n      timeout = setTimeout(() => {\n        fn(...args);\n        lastCall = Date.now();\n        timeout = null;\n      }, wait - timeSinceLastCall);\n    }\n  });\n}\nfunction debounce(fn, wait = 0) {\n  let timeout = null;\n  return ((...args) => {\n    if (timeout) {\n      clearTimeout(timeout);\n      timeout = null;\n    }\n    timeout = setTimeout(() => {\n      fn(...args);\n    }, wait);\n  });\n}\nvar toChar = (code) => String.fromCharCode(code + (code > 25 ? 39 : 97));\nfunction toName(code) {\n  let name = \"\";\n  let x;\n  for (x = Math.abs(code); x > 52; x = x / 52 | 0) name = toChar(x % 52) + name;\n  return toChar(x % 52) + name;\n}\nfunction toPhash(h, x) {\n  let i = x.length;\n  while (i) h = h * 33 ^ x.charCodeAt(--i);\n  return h;\n}\nvar hash = (value) => toName(toPhash(5381, value) >>> 0);\n\n// src/number.ts\nvar { floor, abs, round, min, max, pow, sign } = Math;\nvar isNaN = (v) => Number.isNaN(v);\nvar nan = (v) => isNaN(v) ? 0 : v;\nvar mod = (v, m) => (v % m + m) % m;\nvar wrap = (v, vmax) => (v % vmax + vmax) % vmax;\nvar getMinValueAtIndex = (i, v, vmin) => i === 0 ? vmin : v[i - 1];\nvar getMaxValueAtIndex = (i, v, vmax) => i === v.length - 1 ? vmax : v[i + 1];\nvar isValueAtMax = (v, vmax) => nan(v) >= vmax;\nvar isValueAtMin = (v, vmin) => nan(v) <= vmin;\nvar isValueWithinRange = (v, vmin, vmax) => {\n  const value = nan(v);\n  const minCheck = vmin == null || value >= vmin;\n  const maxCheck = vmax == null || value <= vmax;\n  return minCheck && maxCheck;\n};\nvar roundValue = (v, vmin, step) => round((nan(v) - vmin) / step) * step + vmin;\nvar clampValue = (v, vmin, vmax) => min(max(nan(v), vmin), vmax);\nvar clampPercent = (v) => clampValue(v, 0, 1);\nvar getValuePercent = (v, vmin, vmax) => (nan(v) - vmin) / (vmax - vmin);\nvar getPercentValue = (p, vmin, vmax, step) => clampValue(roundValue(p * (vmax - vmin) + vmin, vmin, step), vmin, vmax);\nvar roundToStepPrecision = (v, step) => {\n  let rv = v;\n  let ss = step.toString();\n  let pi = ss.indexOf(\".\");\n  let p = pi >= 0 ? ss.length - pi : 0;\n  if (p > 0) {\n    let pw = pow(10, p);\n    rv = round(rv * pw) / pw;\n  }\n  return rv;\n};\nvar roundToDpr = (v, dpr) => typeof dpr === \"number\" ? floor(v * dpr + 0.5) / dpr : round(v);\nvar snapValueToStep = (v, vmin, vmax, step) => {\n  const min2 = vmin != null ? Number(vmin) : 0;\n  const max2 = Number(vmax);\n  const remainder = (v - min2) % step;\n  let snapped = abs(remainder) * 2 >= step ? v + sign(remainder) * (step - abs(remainder)) : v - remainder;\n  snapped = roundToStepPrecision(snapped, step);\n  if (!isNaN(min2) && snapped < min2) {\n    snapped = min2;\n  } else if (!isNaN(max2) && snapped > max2) {\n    const stepsInRange = floor((max2 - min2) / step);\n    const largestValidStep = min2 + stepsInRange * step;\n    snapped = stepsInRange <= 0 || largestValidStep < min2 ? max2 : largestValidStep;\n  }\n  return roundToStepPrecision(snapped, step);\n};\nvar setValueAtIndex = (vs, i, v) => {\n  if (vs[i] === v) return vs;\n  return [...vs.slice(0, i), v, ...vs.slice(i + 1)];\n};\nfunction getValueSetterAtIndex(index, ctx) {\n  const minValueAtIndex = getMinValueAtIndex(index, ctx.values, ctx.min);\n  const maxValueAtIndex = getMaxValueAtIndex(index, ctx.values, ctx.max);\n  let nextValues = ctx.values.slice();\n  return function setValue(value) {\n    let nextValue = snapValueToStep(value, minValueAtIndex, maxValueAtIndex, ctx.step);\n    nextValues = setValueAtIndex(nextValues, index, value);\n    nextValues[index] = nextValue;\n    return nextValues;\n  };\n}\nfunction getNextStepValue(index, ctx) {\n  const nextValue = ctx.values[index] + ctx.step;\n  return getValueSetterAtIndex(index, ctx)(nextValue);\n}\nfunction getPreviousStepValue(index, ctx) {\n  const nextValue = ctx.values[index] - ctx.step;\n  return getValueSetterAtIndex(index, ctx)(nextValue);\n}\nvar getClosestValueIndex = (vs, t) => {\n  let i = vs.findIndex((v) => t - v < 0);\n  if (i === 0) return i;\n  if (i === -1) return vs.length - 1;\n  let vLeft = vs[i - 1];\n  let vRight = vs[i];\n  if (abs(vLeft - t) < abs(vRight - t)) return i - 1;\n  return i;\n};\nvar getClosestValue = (vs, t) => vs[getClosestValueIndex(vs, t)];\nvar getValueRanges = (vs, vmin, vmax, gap) => vs.map((v, i) => ({\n  min: i === 0 ? vmin : vs[i - 1] + gap,\n  max: i === vs.length - 1 ? vmax : vs[i + 1] - gap,\n  value: v\n}));\nvar getValueTransformer = (va, vb) => {\n  const [a, b] = va;\n  const [c, d] = vb;\n  return (v) => a === b || c === d ? c : c + (d - c) / (b - a) * (v - a);\n};\nvar toFixedNumber = (v, d = 0, b = 10) => {\n  const pow2 = Math.pow(b, d);\n  return round(v * pow2) / pow2;\n};\nvar countDecimals = (value) => {\n  if (!Number.isFinite(value)) return 0;\n  let e = 1, p = 0;\n  while (Math.round(value * e) / e !== value) {\n    e *= 10;\n    p += 1;\n  }\n  return p;\n};\nvar decimalOp = (a, op, b) => {\n  let result = op === \"+\" ? a + b : a - b;\n  if (a % 1 !== 0 || b % 1 !== 0) {\n    const multiplier = 10 ** Math.max(countDecimals(a), countDecimals(b));\n    a = Math.round(a * multiplier);\n    b = Math.round(b * multiplier);\n    result = op === \"+\" ? a + b : a - b;\n    result /= multiplier;\n  }\n  return result;\n};\nvar incrementValue = (v, s) => decimalOp(nan(v), \"+\", s);\nvar decrementValue = (v, s) => decimalOp(nan(v), \"-\", s);\nvar toPx = (v) => typeof v === \"number\" ? `${v}px` : v;\n\n// src/object.ts\nfunction compact(obj) {\n  if (!isPlainObject(obj) || obj === void 0) return obj;\n  const keys = Reflect.ownKeys(obj).filter((key) => typeof key === \"string\");\n  const filtered = {};\n  for (const key of keys) {\n    const value = obj[key];\n    if (value !== void 0) {\n      filtered[key] = compact(value);\n    }\n  }\n  return filtered;\n}\nvar json = (v) => JSON.parse(JSON.stringify(v));\nfunction pick(obj, keys) {\n  const filtered = {};\n  for (const key of keys) {\n    const value = obj[key];\n    if (value !== void 0) {\n      filtered[key] = value;\n    }\n  }\n  return filtered;\n}\nfunction splitProps(props, keys) {\n  const rest = {};\n  const result = {};\n  const keySet = new Set(keys);\n  const ownKeys = Reflect.ownKeys(props);\n  for (const key of ownKeys) {\n    if (keySet.has(key)) {\n      result[key] = props[key];\n    } else {\n      rest[key] = props[key];\n    }\n  }\n  return [result, rest];\n}\nvar createSplitProps = (keys) => {\n  return function split(props) {\n    return splitProps(props, keys);\n  };\n};\nfunction omit(obj, keys) {\n  return createSplitProps(keys)(obj)[1];\n}\n\n// src/store.ts\nfunction createStore(initialState, compare = Object.is) {\n  let state = { ...initialState };\n  const listeners = /* @__PURE__ */ new Set();\n  const subscribe = (listener) => {\n    listeners.add(listener);\n    return () => listeners.delete(listener);\n  };\n  const publish = () => {\n    listeners.forEach((listener) => listener());\n  };\n  const get = (key) => {\n    return state[key];\n  };\n  const set = (key, value) => {\n    if (!compare(state[key], value)) {\n      state[key] = value;\n      publish();\n    }\n  };\n  const update = (updates) => {\n    let hasChanges = false;\n    for (const key in updates) {\n      const value = updates[key];\n      if (value !== void 0 && !compare(state[key], value)) {\n        state[key] = value;\n        hasChanges = true;\n      }\n    }\n    if (hasChanges) {\n      publish();\n    }\n  };\n  const snapshot = () => ({ ...state });\n  return {\n    subscribe,\n    get,\n    set,\n    update,\n    snapshot\n  };\n}\n\n// src/timers.ts\nvar currentTime = () => performance.now();\nvar _tick;\nvar Timer = class {\n  constructor(onTick) {\n    this.onTick = onTick;\n    __publicField(this, \"frameId\", null);\n    __publicField(this, \"pausedAtMs\", null);\n    __publicField(this, \"context\");\n    __publicField(this, \"cancelFrame\", () => {\n      if (this.frameId === null) return;\n      cancelAnimationFrame(this.frameId);\n      this.frameId = null;\n    });\n    __publicField(this, \"setStartMs\", (startMs) => {\n      this.context.startMs = startMs;\n    });\n    __publicField(this, \"start\", () => {\n      if (this.frameId !== null) return;\n      const now = currentTime();\n      if (this.pausedAtMs !== null) {\n        this.context.startMs += now - this.pausedAtMs;\n        this.pausedAtMs = null;\n      } else {\n        this.context.startMs = now;\n      }\n      this.frameId = requestAnimationFrame(__privateGet(this, _tick));\n    });\n    __publicField(this, \"pause\", () => {\n      if (this.frameId === null) return;\n      this.cancelFrame();\n      this.pausedAtMs = currentTime();\n    });\n    __publicField(this, \"stop\", () => {\n      if (this.frameId === null) return;\n      this.cancelFrame();\n      this.pausedAtMs = null;\n    });\n    __privateAdd(this, _tick, (now) => {\n      this.context.now = now;\n      this.context.deltaMs = now - this.context.startMs;\n      const shouldContinue = this.onTick(this.context);\n      if (shouldContinue === false) {\n        this.stop();\n        return;\n      }\n      this.frameId = requestAnimationFrame(__privateGet(this, _tick));\n    });\n    this.context = { now: 0, startMs: currentTime(), deltaMs: 0 };\n  }\n  get elapsedMs() {\n    if (this.pausedAtMs !== null) {\n      return this.pausedAtMs - this.context.startMs;\n    }\n    return currentTime() - this.context.startMs;\n  }\n};\n_tick = new WeakMap();\nfunction setRafInterval(fn, intervalMs) {\n  const timer = new Timer(({ now, deltaMs }) => {\n    if (deltaMs >= intervalMs) {\n      const startMs = intervalMs > 0 ? now - deltaMs % intervalMs : now;\n      timer.setStartMs(startMs);\n      fn({ startMs, deltaMs });\n    }\n  });\n  timer.start();\n  return () => timer.stop();\n}\nfunction setRafTimeout(fn, delayMs) {\n  const timer = new Timer(({ deltaMs }) => {\n    if (deltaMs >= delayMs) {\n      fn();\n      return false;\n    }\n  });\n  timer.start();\n  return () => timer.stop();\n}\n\n// src/warning.ts\nfunction warn(...a) {\n  const m = a.length === 1 ? a[0] : a[1];\n  const c = a.length === 2 ? a[0] : true;\n  if (c && process.env.NODE_ENV !== \"production\") {\n    console.warn(m);\n  }\n}\nfunction invariant(...a) {\n  const m = a.length === 1 ? a[0] : a[1];\n  const c = a.length === 2 ? a[0] : true;\n  if (c && process.env.NODE_ENV !== \"production\") {\n    throw new Error(m);\n  }\n}\nfunction ensure(c, m) {\n  if (c == null) throw new Error(m());\n}\nfunction ensureProps(props, keys, scope) {\n  let missingKeys = [];\n  for (const key of keys) {\n    if (props[key] == null) missingKeys.push(key);\n  }\n  if (missingKeys.length > 0)\n    throw new Error(`[zag-js${scope ? ` > ${scope}` : \"\"}] missing required props: ${missingKeys.join(\", \")}`);\n}\n\nexport { Timer, add, addOrRemove, callAll, cast, chunk, clampPercent, clampValue, clear, compact, createSplitProps, createStore, debounce, decrementValue, diff, ensure, ensureProps, first, flatArray, fromLength, getClosestValue, getClosestValueIndex, getMaxValueAtIndex, getMinValueAtIndex, getNextStepValue, getPercentValue, getPreviousStepValue, getValuePercent, getValueRanges, getValueSetterAtIndex, getValueTransformer, has, hasProp, hash, identity, incrementValue, insertAt, invariant, isArray, isBoolean, isDev, isEmpty, isEqual, isFunction, isNaN, isNull, isNumber, isObject, isObjectLike, isPlainObject, isString, isValueAtMax, isValueAtMin, isValueWithinRange, json, last, match, mod, nan, next, nextIndex, noop, omit, partition, pick, prev, prevIndex, remove, removeAt, roundToDpr, roundToStepPrecision, roundValue, runIfFn, setRafInterval, setRafTimeout, setValueAtIndex, snapValueToStep, splitProps, throttle, toArray, toFixedNumber, toPx, tryCatch, uniq, uuid, warn, wrap };\n", "var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\n// src/caret.ts\nfunction isCaretAtStart(input) {\n  if (!input) return false;\n  try {\n    return input.selectionStart === 0 && input.selectionEnd === 0;\n  } catch {\n    return input.value === \"\";\n  }\n}\nfunction setCaretToEnd(input) {\n  if (!input) return;\n  try {\n    if (input.ownerDocument.activeElement !== input) return;\n    const len = input.value.length;\n    input.setSelectionRange(len, len);\n  } catch {\n  }\n}\n\n// src/shared.ts\nvar clamp = (value) => Math.max(0, Math.min(1, value));\nvar wrap = (v, idx) => {\n  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);\n};\nvar pipe = (...fns) => (arg) => fns.reduce((acc, fn) => fn(acc), arg);\nvar noop = () => void 0;\nvar isObject = (v) => typeof v === \"object\" && v !== null;\nvar MAX_Z_INDEX = 2147483647;\nvar dataAttr = (guard) => guard ? \"\" : void 0;\nvar ariaAttr = (guard) => guard ? \"true\" : void 0;\n\n// src/node.ts\nvar ELEMENT_NODE = 1;\nvar DOCUMENT_NODE = 9;\nvar DOCUMENT_FRAGMENT_NODE = 11;\nvar isHTMLElement = (el) => isObject(el) && el.nodeType === ELEMENT_NODE && typeof el.nodeName === \"string\";\nvar isDocument = (el) => isObject(el) && el.nodeType === DOCUMENT_NODE;\nvar isWindow = (el) => isObject(el) && el === el.window;\nvar isVisualViewport = (el) => isObject(el) && el.constructor.name === \"VisualViewport\";\nvar getNodeName = (node) => {\n  if (isHTMLElement(node)) return node.localName || \"\";\n  return \"#document\";\n};\nfunction isRootElement(node) {\n  return [\"html\", \"body\", \"#document\"].includes(getNodeName(node));\n}\nvar isNode = (el) => isObject(el) && el.nodeType !== void 0;\nvar isShadowRoot = (el) => isNode(el) && el.nodeType === DOCUMENT_FRAGMENT_NODE && \"host\" in el;\nvar isInputElement = (el) => isHTMLElement(el) && el.localName === \"input\";\nvar isAnchorElement = (el) => !!el?.matches(\"a[href]\");\nvar isElementVisible = (el) => {\n  if (!isHTMLElement(el)) return false;\n  return el.offsetWidth > 0 || el.offsetHeight > 0 || el.getClientRects().length > 0;\n};\nfunction isActiveElement(element) {\n  if (!element) return false;\n  const rootNode = element.getRootNode();\n  return getActiveElement(rootNode) === element;\n}\nvar TEXTAREA_SELECT_REGEX = /(textarea|select)/;\nfunction isEditableElement(el) {\n  if (el == null || !isHTMLElement(el)) return false;\n  try {\n    return isInputElement(el) && el.selectionStart != null || TEXTAREA_SELECT_REGEX.test(el.localName) || el.isContentEditable || el.getAttribute(\"contenteditable\") === \"true\" || el.getAttribute(\"contenteditable\") === \"\";\n  } catch {\n    return false;\n  }\n}\nfunction contains(parent, child) {\n  if (!parent || !child) return false;\n  if (!isHTMLElement(parent) || !isHTMLElement(child)) return false;\n  const rootNode = child.getRootNode?.();\n  if (parent === child) return true;\n  if (parent.contains(child)) return true;\n  if (rootNode && isShadowRoot(rootNode)) {\n    let next = child;\n    while (next) {\n      if (parent === next) return true;\n      next = next.parentNode || next.host;\n    }\n  }\n  return false;\n}\nfunction getDocument(el) {\n  if (isDocument(el)) return el;\n  if (isWindow(el)) return el.document;\n  return el?.ownerDocument ?? document;\n}\nfunction getDocumentElement(el) {\n  return getDocument(el).documentElement;\n}\nfunction getWindow(el) {\n  if (isShadowRoot(el)) return getWindow(el.host);\n  if (isDocument(el)) return el.defaultView ?? window;\n  if (isHTMLElement(el)) return el.ownerDocument?.defaultView ?? window;\n  return window;\n}\nfunction getActiveElement(rootNode) {\n  let activeElement = rootNode.activeElement;\n  while (activeElement?.shadowRoot) {\n    const el = activeElement.shadowRoot.activeElement;\n    if (!el || el === activeElement) break;\n    else activeElement = el;\n  }\n  return activeElement;\n}\nfunction getParentNode(node) {\n  if (getNodeName(node) === \"html\") return node;\n  const result = node.assignedSlot || node.parentNode || isShadowRoot(node) && node.host || getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\nfunction getRootNode(node) {\n  let result;\n  try {\n    result = node.getRootNode({ composed: true });\n    if (isDocument(result) || isShadowRoot(result)) return result;\n  } catch {\n  }\n  return node.ownerDocument ?? document;\n}\n\n// src/computed-style.ts\nvar styleCache = /* @__PURE__ */ new WeakMap();\nfunction getComputedStyle(el) {\n  if (!styleCache.has(el)) {\n    styleCache.set(el, getWindow(el).getComputedStyle(el));\n  }\n  return styleCache.get(el);\n}\n\n// src/controller.ts\nvar INTERACTIVE_CONTAINER_ROLE = /* @__PURE__ */ new Set([\"menu\", \"listbox\", \"dialog\", \"grid\", \"tree\", \"region\"]);\nvar isInteractiveContainerRole = (role) => INTERACTIVE_CONTAINER_ROLE.has(role);\nvar getAriaControls = (element) => element.getAttribute(\"aria-controls\")?.split(\" \") || [];\nfunction isControlledElement(container, element) {\n  const visitedIds = /* @__PURE__ */ new Set();\n  const rootNode = getRootNode(container);\n  const checkElement = (searchRoot) => {\n    const controllingElements = searchRoot.querySelectorAll(\"[aria-controls]\");\n    for (const controller of controllingElements) {\n      if (controller.getAttribute(\"aria-expanded\") !== \"true\") continue;\n      const controlledIds = getAriaControls(controller);\n      for (const id of controlledIds) {\n        if (!id || visitedIds.has(id)) continue;\n        visitedIds.add(id);\n        const controlledElement = rootNode.getElementById(id);\n        if (controlledElement) {\n          const role = controlledElement.getAttribute(\"role\");\n          const modal = controlledElement.getAttribute(\"aria-modal\") === \"true\";\n          if (role && isInteractiveContainerRole(role) && !modal) {\n            if (controlledElement === element || controlledElement.contains(element)) {\n              return true;\n            }\n            if (checkElement(controlledElement)) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n    return false;\n  };\n  return checkElement(container);\n}\nfunction findControlledElements(searchRoot, callback) {\n  const rootNode = getRootNode(searchRoot);\n  const visitedIds = /* @__PURE__ */ new Set();\n  const findRecursive = (root) => {\n    const controllingElements = root.querySelectorAll(\"[aria-controls]\");\n    for (const controller of controllingElements) {\n      if (controller.getAttribute(\"aria-expanded\") !== \"true\") continue;\n      const controlledIds = getAriaControls(controller);\n      for (const id of controlledIds) {\n        if (!id || visitedIds.has(id)) continue;\n        visitedIds.add(id);\n        const controlledElement = rootNode.getElementById(id);\n        if (controlledElement) {\n          const role = controlledElement.getAttribute(\"role\");\n          const modal = controlledElement.getAttribute(\"aria-modal\") === \"true\";\n          if (role && INTERACTIVE_CONTAINER_ROLE.has(role) && !modal) {\n            callback(controlledElement);\n            findRecursive(controlledElement);\n          }\n        }\n      }\n    }\n  };\n  findRecursive(searchRoot);\n}\nfunction getControlledElements(container) {\n  const controlledElements = /* @__PURE__ */ new Set();\n  findControlledElements(container, (controlledElement) => {\n    if (!container.contains(controlledElement)) {\n      controlledElements.add(controlledElement);\n    }\n  });\n  return Array.from(controlledElements);\n}\nfunction isInteractiveContainerElement(element) {\n  const role = element.getAttribute(\"role\");\n  return Boolean(role && INTERACTIVE_CONTAINER_ROLE.has(role));\n}\nfunction isControllerElement(element) {\n  return element.hasAttribute(\"aria-controls\") && element.getAttribute(\"aria-expanded\") === \"true\";\n}\nfunction hasControllerElements(element) {\n  if (isControllerElement(element)) return true;\n  return Boolean(element.querySelector?.('[aria-controls][aria-expanded=\"true\"]'));\n}\nfunction isControlledByExpandedController(element) {\n  if (!element.id) return false;\n  const rootNode = getRootNode(element);\n  const escapedId = CSS.escape(element.id);\n  const selector = `[aria-controls~=\"${escapedId}\"][aria-expanded=\"true\"], [aria-controls=\"${escapedId}\"][aria-expanded=\"true\"]`;\n  const controller = rootNode.querySelector(selector);\n  return Boolean(controller && isInteractiveContainerElement(element));\n}\n\n// src/data-url.ts\nfunction getDataUrl(svg, opts) {\n  const { type, quality = 0.92, background } = opts;\n  if (!svg) throw new Error(\"[zag-js > getDataUrl]: Could not find the svg element\");\n  const win = getWindow(svg);\n  const doc = win.document;\n  const svgBounds = svg.getBoundingClientRect();\n  const svgClone = svg.cloneNode(true);\n  if (!svgClone.hasAttribute(\"viewBox\")) {\n    svgClone.setAttribute(\"viewBox\", `0 0 ${svgBounds.width} ${svgBounds.height}`);\n  }\n  const serializer = new win.XMLSerializer();\n  const source = '<?xml version=\"1.0\" standalone=\"no\"?>\\r\\n' + serializer.serializeToString(svgClone);\n  const svgString = \"data:image/svg+xml;charset=utf-8,\" + encodeURIComponent(source);\n  if (type === \"image/svg+xml\") {\n    return Promise.resolve(svgString).then((str) => {\n      svgClone.remove();\n      return str;\n    });\n  }\n  const dpr = win.devicePixelRatio || 1;\n  const canvas = doc.createElement(\"canvas\");\n  const image = new win.Image();\n  image.src = svgString;\n  canvas.width = svgBounds.width * dpr;\n  canvas.height = svgBounds.height * dpr;\n  const context = canvas.getContext(\"2d\");\n  if (type === \"image/jpeg\" || background) {\n    context.fillStyle = background || \"white\";\n    context.fillRect(0, 0, canvas.width, canvas.height);\n  }\n  return new Promise((resolve) => {\n    image.onload = () => {\n      context?.drawImage(image, 0, 0, canvas.width, canvas.height);\n      resolve(canvas.toDataURL(type, quality));\n      svgClone.remove();\n    };\n  });\n}\n\n// src/platform.ts\nvar isDom = () => typeof document !== \"undefined\";\nfunction getPlatform() {\n  const agent = navigator.userAgentData;\n  return agent?.platform ?? navigator.platform;\n}\nfunction getUserAgent() {\n  const ua2 = navigator.userAgentData;\n  if (ua2 && Array.isArray(ua2.brands)) {\n    return ua2.brands.map(({ brand, version }) => `${brand}/${version}`).join(\" \");\n  }\n  return navigator.userAgent;\n}\nvar pt = (v) => isDom() && v.test(getPlatform());\nvar ua = (v) => isDom() && v.test(getUserAgent());\nvar vn = (v) => isDom() && v.test(navigator.vendor);\nvar isTouchDevice = () => isDom() && !!navigator.maxTouchPoints;\nvar isIPhone = () => pt(/^iPhone/i);\nvar isIPad = () => pt(/^iPad/i) || isMac() && navigator.maxTouchPoints > 1;\nvar isIos = () => isIPhone() || isIPad();\nvar isApple = () => isMac() || isIos();\nvar isMac = () => pt(/^Mac/i);\nvar isSafari = () => isApple() && vn(/apple/i);\nvar isFirefox = () => ua(/Firefox/i);\nvar isChrome = () => ua(/Chrome/i);\nvar isWebKit = () => ua(/AppleWebKit/i) && !isChrome();\nvar isAndroid = () => ua(/Android/i);\n\n// src/event.ts\nfunction getBeforeInputValue(event) {\n  const { selectionStart, selectionEnd, value } = event.currentTarget;\n  const data = event.data;\n  return value.slice(0, selectionStart) + (data ?? \"\") + value.slice(selectionEnd);\n}\nfunction getComposedPath(event) {\n  return event.composedPath?.() ?? event.nativeEvent?.composedPath?.();\n}\nfunction getEventTarget(event) {\n  const composedPath = getComposedPath(event);\n  return composedPath?.[0] ?? event.target;\n}\nfunction isOpeningInNewTab(event) {\n  const element = event.currentTarget;\n  if (!element) return false;\n  const validElement = element.matches(\"a[href], button[type='submit'], input[type='submit']\");\n  if (!validElement) return false;\n  const isMiddleClick = event.button === 1;\n  const isModKeyClick = isCtrlOrMetaKey(event);\n  return isMiddleClick || isModKeyClick;\n}\nfunction isDownloadingEvent(event) {\n  const element = event.currentTarget;\n  if (!element) return false;\n  const localName = element.localName;\n  if (!event.altKey) return false;\n  if (localName === \"a\") return true;\n  if (localName === \"button\" && element.type === \"submit\") return true;\n  if (localName === \"input\" && element.type === \"submit\") return true;\n  return false;\n}\nfunction isComposingEvent(event) {\n  return getNativeEvent(event).isComposing || event.keyCode === 229;\n}\nfunction isKeyboardClick(e) {\n  return e.detail === 0 || e.clientX === 0 && e.clientY === 0;\n}\nfunction isCtrlOrMetaKey(e) {\n  if (isMac()) return e.metaKey;\n  return e.ctrlKey;\n}\nfunction isPrintableKey(e) {\n  return e.key.length === 1 && !e.ctrlKey && !e.metaKey;\n}\nfunction isVirtualPointerEvent(e) {\n  return e.width === 0 && e.height === 0 || e.width === 1 && e.height === 1 && e.pressure === 0 && e.detail === 0 && e.pointerType === \"mouse\";\n}\nfunction isVirtualClick(e) {\n  if (e.pointerType === \"\" && e.isTrusted) return true;\n  if (isAndroid() && e.pointerType) {\n    return e.type === \"click\" && e.buttons === 1;\n  }\n  return e.detail === 0 && !e.pointerType;\n}\nvar isLeftClick = (e) => e.button === 0;\nvar isContextMenuEvent = (e) => {\n  return e.button === 2 || isMac() && e.ctrlKey && e.button === 0;\n};\nvar isModifierKey = (e) => e.ctrlKey || e.altKey || e.metaKey;\nvar isTouchEvent = (event) => \"touches\" in event && event.touches.length > 0;\nvar keyMap = {\n  Up: \"ArrowUp\",\n  Down: \"ArrowDown\",\n  Esc: \"Escape\",\n  \" \": \"Space\",\n  \",\": \"Comma\",\n  Left: \"ArrowLeft\",\n  Right: \"ArrowRight\"\n};\nvar rtlKeyMap = {\n  ArrowLeft: \"ArrowRight\",\n  ArrowRight: \"ArrowLeft\"\n};\nfunction getEventKey(event, options = {}) {\n  const { dir = \"ltr\", orientation = \"horizontal\" } = options;\n  let key = event.key;\n  key = keyMap[key] ?? key;\n  const isRtl = dir === \"rtl\" && orientation === \"horizontal\";\n  if (isRtl && key in rtlKeyMap) key = rtlKeyMap[key];\n  return key;\n}\nfunction getNativeEvent(event) {\n  return event.nativeEvent ?? event;\n}\nvar pageKeys = /* @__PURE__ */ new Set([\"PageUp\", \"PageDown\"]);\nvar arrowKeys = /* @__PURE__ */ new Set([\"ArrowUp\", \"ArrowDown\", \"ArrowLeft\", \"ArrowRight\"]);\nfunction getEventStep(event) {\n  if (event.ctrlKey || event.metaKey) {\n    return 0.1;\n  } else {\n    const isPageKey = pageKeys.has(event.key);\n    const isSkipKey = isPageKey || event.shiftKey && arrowKeys.has(event.key);\n    return isSkipKey ? 10 : 1;\n  }\n}\nfunction getEventPoint(event, type = \"client\") {\n  const point = isTouchEvent(event) ? event.touches[0] || event.changedTouches[0] : event;\n  return { x: point[`${type}X`], y: point[`${type}Y`] };\n}\nvar addDomEvent = (target, eventName, handler, options) => {\n  const node = typeof target === \"function\" ? target() : target;\n  node?.addEventListener(eventName, handler, options);\n  return () => {\n    node?.removeEventListener(eventName, handler, options);\n  };\n};\nvar isSelfTarget = (event) => {\n  const composedPath = getComposedPath(event);\n  const target = composedPath?.[0] ?? event.target;\n  return event.currentTarget === target;\n};\n\n// src/form.ts\nfunction getDescriptor(el, options) {\n  const { type = \"HTMLInputElement\", property = \"value\" } = options;\n  const proto = getWindow(el)[type].prototype;\n  return Object.getOwnPropertyDescriptor(proto, property) ?? {};\n}\nfunction getElementType(el) {\n  if (el.localName === \"input\") return \"HTMLInputElement\";\n  if (el.localName === \"textarea\") return \"HTMLTextAreaElement\";\n  if (el.localName === \"select\") return \"HTMLSelectElement\";\n}\nfunction setElementValue(el, value, property = \"value\") {\n  if (!el) return;\n  const type = getElementType(el);\n  if (type) {\n    const descriptor = getDescriptor(el, { type, property });\n    descriptor.set?.call(el, value);\n  }\n  el.setAttribute(property, value);\n}\nfunction setElementChecked(el, checked) {\n  if (!el) return;\n  const descriptor = getDescriptor(el, { type: \"HTMLInputElement\", property: \"checked\" });\n  descriptor.set?.call(el, checked);\n  if (checked) el.setAttribute(\"checked\", \"\");\n  else el.removeAttribute(\"checked\");\n}\nfunction dispatchInputValueEvent(el, options) {\n  const { value, bubbles = true } = options;\n  if (!el) return;\n  const win = getWindow(el);\n  if (!(el instanceof win.HTMLInputElement)) return;\n  setElementValue(el, `${value}`);\n  el.dispatchEvent(new win.Event(\"input\", { bubbles }));\n}\nfunction dispatchInputCheckedEvent(el, options) {\n  const { checked, bubbles = true } = options;\n  if (!el) return;\n  const win = getWindow(el);\n  if (!(el instanceof win.HTMLInputElement)) return;\n  setElementChecked(el, checked);\n  el.dispatchEvent(new win.Event(\"click\", { bubbles }));\n}\nfunction getClosestForm(el) {\n  return isFormElement(el) ? el.form : el.closest(\"form\");\n}\nfunction isFormElement(el) {\n  return el.matches(\"textarea, input, select, button\");\n}\nfunction trackFormReset(el, callback) {\n  if (!el) return;\n  const form = getClosestForm(el);\n  const onReset = (e) => {\n    if (e.defaultPrevented) return;\n    callback();\n  };\n  form?.addEventListener(\"reset\", onReset, { passive: true });\n  return () => form?.removeEventListener(\"reset\", onReset);\n}\nfunction trackFieldsetDisabled(el, callback) {\n  const fieldset = el?.closest(\"fieldset\");\n  if (!fieldset) return;\n  callback(fieldset.disabled);\n  const win = getWindow(fieldset);\n  const obs = new win.MutationObserver(() => callback(fieldset.disabled));\n  obs.observe(fieldset, {\n    attributes: true,\n    attributeFilter: [\"disabled\"]\n  });\n  return () => obs.disconnect();\n}\nfunction trackFormControl(el, options) {\n  if (!el) return;\n  const { onFieldsetDisabledChange, onFormReset } = options;\n  const cleanups = [trackFormReset(el, onFormReset), trackFieldsetDisabled(el, onFieldsetDisabledChange)];\n  return () => cleanups.forEach((cleanup) => cleanup?.());\n}\n\n// src/tabbable.ts\nvar isFrame = (el) => isHTMLElement(el) && el.tagName === \"IFRAME\";\nvar NATURALLY_TABBABLE_REGEX = /^(audio|video|details)$/;\nfunction parseTabIndex(el) {\n  const attr = el.getAttribute(\"tabindex\");\n  if (!attr) return NaN;\n  return parseInt(attr, 10);\n}\nvar hasTabIndex = (el) => !Number.isNaN(parseTabIndex(el));\nvar hasNegativeTabIndex = (el) => parseTabIndex(el) < 0;\nfunction getShadowRootForNode(element, getShadowRoot) {\n  if (!getShadowRoot) return null;\n  if (getShadowRoot === true) {\n    return element.shadowRoot || null;\n  }\n  const result = getShadowRoot(element);\n  return (result === true ? element.shadowRoot : result) || null;\n}\nfunction collectElementsWithShadowDOM(elements, getShadowRoot, filterFn) {\n  const allElements = [...elements];\n  const toProcess = [...elements];\n  const processed = /* @__PURE__ */ new Set();\n  const positionMap = /* @__PURE__ */ new Map();\n  elements.forEach((el, i) => positionMap.set(el, i));\n  let processIndex = 0;\n  while (processIndex < toProcess.length) {\n    const element = toProcess[processIndex++];\n    if (!element || processed.has(element)) continue;\n    processed.add(element);\n    const shadowRoot = getShadowRootForNode(element, getShadowRoot);\n    if (shadowRoot) {\n      const shadowElements = Array.from(shadowRoot.querySelectorAll(focusableSelector)).filter(filterFn);\n      const hostIndex = positionMap.get(element);\n      if (hostIndex !== void 0) {\n        const insertPosition = hostIndex + 1;\n        allElements.splice(insertPosition, 0, ...shadowElements);\n        shadowElements.forEach((el, i) => {\n          positionMap.set(el, insertPosition + i);\n        });\n        for (let i = insertPosition + shadowElements.length; i < allElements.length; i++) {\n          positionMap.set(allElements[i], i);\n        }\n      } else {\n        const insertPosition = allElements.length;\n        allElements.push(...shadowElements);\n        shadowElements.forEach((el, i) => {\n          positionMap.set(el, insertPosition + i);\n        });\n      }\n      toProcess.push(...shadowElements);\n    }\n  }\n  return allElements;\n}\nvar focusableSelector = \"input:not([type='hidden']):not([disabled]), select:not([disabled]), textarea:not([disabled]), a[href], button:not([disabled]), [tabindex], iframe, object, embed, area[href], audio[controls], video[controls], [contenteditable]:not([contenteditable='false']), details > summary:first-of-type\";\nvar getFocusables = (container, options = {}) => {\n  if (!container) return [];\n  const { includeContainer = false, getShadowRoot } = options;\n  const elements = Array.from(container.querySelectorAll(focusableSelector));\n  const include = includeContainer == true || includeContainer == \"if-empty\" && elements.length === 0;\n  if (include && isHTMLElement(container) && isFocusable(container)) {\n    elements.unshift(container);\n  }\n  const focusableElements = [];\n  for (const element of elements) {\n    if (!isFocusable(element)) continue;\n    if (isFrame(element) && element.contentDocument) {\n      const frameBody = element.contentDocument.body;\n      focusableElements.push(...getFocusables(frameBody, { getShadowRoot }));\n      continue;\n    }\n    focusableElements.push(element);\n  }\n  if (getShadowRoot) {\n    return collectElementsWithShadowDOM(focusableElements, getShadowRoot, isFocusable);\n  }\n  return focusableElements;\n};\nfunction isFocusable(element) {\n  if (!isHTMLElement(element) || element.closest(\"[inert]\")) return false;\n  return element.matches(focusableSelector) && isElementVisible(element);\n}\nfunction getFirstFocusable(container, options = {}) {\n  const [first] = getFocusables(container, options);\n  return first || null;\n}\nfunction getTabbables(container, options = {}) {\n  if (!container) return [];\n  const { includeContainer, getShadowRoot } = options;\n  const elements = Array.from(container.querySelectorAll(focusableSelector));\n  if (includeContainer && isTabbable(container)) {\n    elements.unshift(container);\n  }\n  const tabbableElements = [];\n  for (const element of elements) {\n    if (!isTabbable(element)) continue;\n    if (isFrame(element) && element.contentDocument) {\n      const frameBody = element.contentDocument.body;\n      tabbableElements.push(...getTabbables(frameBody, { getShadowRoot }));\n      continue;\n    }\n    tabbableElements.push(element);\n  }\n  if (getShadowRoot) {\n    const allElements = collectElementsWithShadowDOM(tabbableElements, getShadowRoot, isTabbable);\n    if (!allElements.length && includeContainer) {\n      return elements;\n    }\n    return allElements;\n  }\n  if (!tabbableElements.length && includeContainer) {\n    return elements;\n  }\n  return tabbableElements;\n}\nfunction isTabbable(el) {\n  if (isHTMLElement(el) && el.tabIndex > 0) return true;\n  return isFocusable(el) && !hasNegativeTabIndex(el);\n}\nfunction getFirstTabbable(container, options = {}) {\n  const [first] = getTabbables(container, options);\n  return first || null;\n}\nfunction getLastTabbable(container, options = {}) {\n  const elements = getTabbables(container, options);\n  return elements[elements.length - 1] || null;\n}\nfunction getTabbableEdges(container, options = {}) {\n  const elements = getTabbables(container, options);\n  const first = elements[0] || null;\n  const last = elements[elements.length - 1] || null;\n  return [first, last];\n}\nfunction getNextTabbable(container, options = {}) {\n  const { current, getShadowRoot } = options;\n  const tabbables = getTabbables(container, { getShadowRoot });\n  const doc = container?.ownerDocument || document;\n  const currentElement = current ?? getActiveElement(doc);\n  if (!currentElement) return null;\n  const index = tabbables.indexOf(currentElement);\n  return tabbables[index + 1] || null;\n}\nfunction getTabIndex(node) {\n  if (node.tabIndex < 0) {\n    if ((NATURALLY_TABBABLE_REGEX.test(node.localName) || isEditableElement(node)) && !hasTabIndex(node)) {\n      return 0;\n    }\n  }\n  return node.tabIndex;\n}\n\n// src/initial-focus.ts\nfunction getInitialFocus(options) {\n  const { root, getInitialEl, filter, enabled = true } = options;\n  if (!enabled) return;\n  let node = null;\n  node || (node = typeof getInitialEl === \"function\" ? getInitialEl() : getInitialEl);\n  node || (node = root?.querySelector(\"[data-autofocus],[autofocus]\"));\n  if (!node) {\n    const tabbables = getTabbables(root);\n    node = filter ? tabbables.filter(filter)[0] : tabbables[0];\n  }\n  return node || root || void 0;\n}\nfunction isValidTabEvent(event) {\n  const container = event.currentTarget;\n  if (!container) return false;\n  const [firstTabbable, lastTabbable] = getTabbableEdges(container);\n  if (isActiveElement(firstTabbable) && event.shiftKey) return false;\n  if (isActiveElement(lastTabbable) && !event.shiftKey) return false;\n  if (!firstTabbable && !lastTabbable) return false;\n  return true;\n}\n\n// src/raf.ts\nvar AnimationFrame = class _AnimationFrame {\n  constructor() {\n    __publicField(this, \"id\", null);\n    __publicField(this, \"fn_cleanup\");\n    __publicField(this, \"cleanup\", () => {\n      this.cancel();\n    });\n  }\n  static create() {\n    return new _AnimationFrame();\n  }\n  request(fn) {\n    this.cancel();\n    this.id = globalThis.requestAnimationFrame(() => {\n      this.id = null;\n      this.fn_cleanup = fn?.();\n    });\n  }\n  cancel() {\n    if (this.id !== null) {\n      globalThis.cancelAnimationFrame(this.id);\n      this.id = null;\n    }\n    this.fn_cleanup?.();\n    this.fn_cleanup = void 0;\n  }\n  isActive() {\n    return this.id !== null;\n  }\n};\nfunction raf(fn) {\n  const frame = AnimationFrame.create();\n  frame.request(fn);\n  return frame.cleanup;\n}\nfunction nextTick(fn) {\n  const set = /* @__PURE__ */ new Set();\n  function raf2(fn2) {\n    const id = globalThis.requestAnimationFrame(fn2);\n    set.add(() => globalThis.cancelAnimationFrame(id));\n  }\n  raf2(() => raf2(fn));\n  return function cleanup() {\n    set.forEach((fn2) => fn2());\n  };\n}\nfunction queueBeforeEvent(el, type, cb) {\n  const cancelTimer = raf(() => {\n    el.removeEventListener(type, exec, true);\n    cb();\n  });\n  const exec = () => {\n    cancelTimer();\n    cb();\n  };\n  el.addEventListener(type, exec, { once: true, capture: true });\n  return cancelTimer;\n}\n\n// src/mutation-observer.ts\nfunction observeAttributesImpl(node, options) {\n  if (!node) return;\n  const { attributes, callback: fn } = options;\n  const win = node.ownerDocument.defaultView || window;\n  const obs = new win.MutationObserver((changes) => {\n    for (const change of changes) {\n      if (change.type === \"attributes\" && change.attributeName && attributes.includes(change.attributeName)) {\n        fn(change);\n      }\n    }\n  });\n  obs.observe(node, { attributes: true, attributeFilter: attributes });\n  return () => obs.disconnect();\n}\nfunction observeAttributes(nodeOrFn, options) {\n  const { defer } = options;\n  const func = defer ? raf : (v) => v();\n  const cleanups = [];\n  cleanups.push(\n    func(() => {\n      const node = typeof nodeOrFn === \"function\" ? nodeOrFn() : nodeOrFn;\n      cleanups.push(observeAttributesImpl(node, options));\n    })\n  );\n  return () => {\n    cleanups.forEach((fn) => fn?.());\n  };\n}\nfunction observeChildrenImpl(node, options) {\n  const { callback: fn } = options;\n  if (!node) return;\n  const win = node.ownerDocument.defaultView || window;\n  const obs = new win.MutationObserver(fn);\n  obs.observe(node, { childList: true, subtree: true });\n  return () => obs.disconnect();\n}\nfunction observeChildren(nodeOrFn, options) {\n  const { defer } = options;\n  const func = defer ? raf : (v) => v();\n  const cleanups = [];\n  cleanups.push(\n    func(() => {\n      const node = typeof nodeOrFn === \"function\" ? nodeOrFn() : nodeOrFn;\n      cleanups.push(observeChildrenImpl(node, options));\n    })\n  );\n  return () => {\n    cleanups.forEach((fn) => fn?.());\n  };\n}\n\n// src/navigate.ts\nfunction navigate(items, current, options = {}) {\n  if (!current) return null;\n  const { orientation = \"both\", loop = true, dir = \"ltr\", key } = options;\n  if (!items.length || !key) return null;\n  const isVertical = key === \"ArrowUp\" || key === \"ArrowDown\";\n  const isHorizontal = key === \"ArrowLeft\" || key === \"ArrowRight\";\n  if (!isVertical && !isHorizontal && key !== \"Home\" && key !== \"End\") return null;\n  if (orientation === \"vertical\" && isHorizontal || orientation === \"horizontal\" && isVertical) return null;\n  if (key === \"Home\") return items[0] || null;\n  if (key === \"End\") return items[items.length - 1] || null;\n  const idx = items.indexOf(current);\n  if (idx === -1) return null;\n  let isForward;\n  if (orientation === \"both\") {\n    isForward = key === \"ArrowDown\" || (dir === \"ltr\" ? key === \"ArrowRight\" : key === \"ArrowLeft\");\n  } else {\n    isForward = isVertical ? key === \"ArrowDown\" : dir === \"ltr\" ? key === \"ArrowRight\" : key === \"ArrowLeft\";\n  }\n  const nextIdx = isForward ? loop ? (idx + 1) % items.length : Math.min(idx + 1, items.length - 1) : loop ? (idx - 1 + items.length) % items.length : Math.max(0, idx - 1);\n  return items[nextIdx] || null;\n}\nfunction clickIfLink(el) {\n  const click = () => {\n    const win = getWindow(el);\n    el.dispatchEvent(new win.MouseEvent(\"click\"));\n  };\n  if (isFirefox()) {\n    queueBeforeEvent(el, \"keyup\", click);\n  } else {\n    queueMicrotask(click);\n  }\n}\n\n// src/overflow.ts\nfunction getNearestOverflowAncestor(el) {\n  const parentNode = getParentNode(el);\n  if (isRootElement(parentNode)) return getDocument(parentNode).body;\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) return parentNode;\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(el, list = []) {\n  const scrollableAncestor = getNearestOverflowAncestor(el);\n  const isBody = scrollableAncestor === el.ownerDocument.body;\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, []));\n}\nvar getElementRect = (el) => {\n  if (isHTMLElement(el)) return el.getBoundingClientRect();\n  if (isVisualViewport(el)) return { top: 0, left: 0, bottom: el.height, right: el.width };\n  return { top: 0, left: 0, bottom: el.innerHeight, right: el.innerWidth };\n};\nfunction isInView(el, ancestor) {\n  if (!isHTMLElement(el)) return true;\n  const ancestorRect = getElementRect(ancestor);\n  const elRect = el.getBoundingClientRect();\n  return elRect.top >= ancestorRect.top && elRect.left >= ancestorRect.left && elRect.bottom <= ancestorRect.bottom && elRect.right <= ancestorRect.right;\n}\nvar OVERFLOW_RE = /auto|scroll|overlay|hidden|clip/;\nvar nonOverflowValues = /* @__PURE__ */ new Set([\"inline\", \"contents\"]);\nfunction isOverflowElement(el) {\n  const win = getWindow(el);\n  const { overflow, overflowX, overflowY, display } = win.getComputedStyle(el);\n  return OVERFLOW_RE.test(overflow + overflowY + overflowX) && !nonOverflowValues.has(display);\n}\nfunction isScrollable(el) {\n  return el.scrollHeight > el.clientHeight || el.scrollWidth > el.clientWidth;\n}\nfunction scrollIntoView(el, options) {\n  const { rootEl, ...scrollOptions } = options || {};\n  if (!el || !rootEl) return;\n  if (!isOverflowElement(rootEl) || !isScrollable(rootEl)) return;\n  el.scrollIntoView(scrollOptions);\n}\nfunction getScrollPosition(element) {\n  if (isHTMLElement(element)) {\n    return { scrollLeft: element.scrollLeft, scrollTop: element.scrollTop };\n  }\n  return { scrollLeft: element.scrollX, scrollTop: element.scrollY };\n}\n\n// src/point.ts\nfunction getRelativePoint(point, element) {\n  const { left, top, width, height } = element.getBoundingClientRect();\n  const offset = { x: point.x - left, y: point.y - top };\n  const percent = { x: clamp(offset.x / width), y: clamp(offset.y / height) };\n  function getPercentValue(options = {}) {\n    const { dir = \"ltr\", orientation = \"horizontal\", inverted } = options;\n    const invertX = typeof inverted === \"object\" ? inverted.x : inverted;\n    const invertY = typeof inverted === \"object\" ? inverted.y : inverted;\n    if (orientation === \"horizontal\") {\n      return dir === \"rtl\" || invertX ? 1 - percent.x : percent.x;\n    }\n    return invertY ? 1 - percent.y : percent.y;\n  }\n  return { offset, percent, getPercentValue };\n}\n\n// src/pointer-lock.ts\nfunction requestPointerLock(doc, fn) {\n  const body = doc.body;\n  const supported = \"pointerLockElement\" in doc || \"mozPointerLockElement\" in doc;\n  const isLocked = () => !!doc.pointerLockElement;\n  function onPointerChange() {\n    fn?.(isLocked());\n  }\n  function onPointerError(event) {\n    if (isLocked()) fn?.(false);\n    console.error(\"PointerLock error occurred:\", event);\n    doc.exitPointerLock();\n  }\n  if (!supported) return;\n  try {\n    body.requestPointerLock();\n  } catch {\n  }\n  const cleanup = [\n    addDomEvent(doc, \"pointerlockchange\", onPointerChange, false),\n    addDomEvent(doc, \"pointerlockerror\", onPointerError, false)\n  ];\n  return () => {\n    cleanup.forEach((cleanup2) => cleanup2());\n    doc.exitPointerLock();\n  };\n}\n\n// src/text-selection.ts\nvar state = \"default\";\nvar userSelect = \"\";\nvar elementMap = /* @__PURE__ */ new WeakMap();\nfunction disableTextSelectionImpl(options = {}) {\n  const { target, doc } = options;\n  const docNode = doc ?? document;\n  const rootEl = docNode.documentElement;\n  if (isIos()) {\n    if (state === \"default\") {\n      userSelect = rootEl.style.webkitUserSelect;\n      rootEl.style.webkitUserSelect = \"none\";\n    }\n    state = \"disabled\";\n  } else if (target) {\n    elementMap.set(target, target.style.userSelect);\n    target.style.userSelect = \"none\";\n  }\n  return () => restoreTextSelection({ target, doc: docNode });\n}\nfunction restoreTextSelection(options = {}) {\n  const { target, doc } = options;\n  const docNode = doc ?? document;\n  const rootEl = docNode.documentElement;\n  if (isIos()) {\n    if (state !== \"disabled\") return;\n    state = \"restoring\";\n    setTimeout(() => {\n      nextTick(() => {\n        if (state === \"restoring\") {\n          if (rootEl.style.webkitUserSelect === \"none\") {\n            rootEl.style.webkitUserSelect = userSelect || \"\";\n          }\n          userSelect = \"\";\n          state = \"default\";\n        }\n      });\n    }, 300);\n  } else {\n    if (target && elementMap.has(target)) {\n      const prevUserSelect = elementMap.get(target);\n      if (target.style.userSelect === \"none\") {\n        target.style.userSelect = prevUserSelect ?? \"\";\n      }\n      if (target.getAttribute(\"style\") === \"\") {\n        target.removeAttribute(\"style\");\n      }\n      elementMap.delete(target);\n    }\n  }\n}\nfunction disableTextSelection(options = {}) {\n  const { defer, target, ...restOptions } = options;\n  const func = defer ? raf : (v) => v();\n  const cleanups = [];\n  cleanups.push(\n    func(() => {\n      const node = typeof target === \"function\" ? target() : target;\n      cleanups.push(disableTextSelectionImpl({ ...restOptions, target: node }));\n    })\n  );\n  return () => {\n    cleanups.forEach((fn) => fn?.());\n  };\n}\n\n// src/pointer-move.ts\nfunction trackPointerMove(doc, handlers) {\n  const { onPointerMove, onPointerUp } = handlers;\n  const handleMove = (event) => {\n    const point = getEventPoint(event);\n    const distance = Math.sqrt(point.x ** 2 + point.y ** 2);\n    const moveBuffer = event.pointerType === \"touch\" ? 10 : 5;\n    if (distance < moveBuffer) return;\n    if (event.pointerType === \"mouse\" && event.buttons === 0) {\n      handleUp(event);\n      return;\n    }\n    onPointerMove({ point, event });\n  };\n  const handleUp = (event) => {\n    const point = getEventPoint(event);\n    onPointerUp({ point, event });\n  };\n  const cleanups = [\n    addDomEvent(doc, \"pointermove\", handleMove, false),\n    addDomEvent(doc, \"pointerup\", handleUp, false),\n    addDomEvent(doc, \"pointercancel\", handleUp, false),\n    addDomEvent(doc, \"contextmenu\", handleUp, false),\n    disableTextSelection({ doc })\n  ];\n  return () => {\n    cleanups.forEach((cleanup) => cleanup());\n  };\n}\n\n// src/press.ts\nfunction trackPress(options) {\n  const {\n    pointerNode,\n    keyboardNode = pointerNode,\n    onPress,\n    onPressStart,\n    onPressEnd,\n    isValidKey = (e) => e.key === \"Enter\"\n  } = options;\n  if (!pointerNode) return noop;\n  const win = getWindow(pointerNode);\n  let removeStartListeners = noop;\n  let removeEndListeners = noop;\n  let removeAccessibleListeners = noop;\n  const getInfo = (event) => ({\n    point: getEventPoint(event),\n    event\n  });\n  function startPress(event) {\n    onPressStart?.(getInfo(event));\n  }\n  function cancelPress(event) {\n    onPressEnd?.(getInfo(event));\n  }\n  const startPointerPress = (startEvent) => {\n    removeEndListeners();\n    const endPointerPress = (endEvent) => {\n      const target = getEventTarget(endEvent);\n      if (contains(pointerNode, target)) {\n        onPress?.(getInfo(endEvent));\n      } else {\n        onPressEnd?.(getInfo(endEvent));\n      }\n    };\n    const removePointerUpListener = addDomEvent(win, \"pointerup\", endPointerPress, { passive: !onPress, once: true });\n    const removePointerCancelListener = addDomEvent(win, \"pointercancel\", cancelPress, {\n      passive: !onPressEnd,\n      once: true\n    });\n    removeEndListeners = pipe(removePointerUpListener, removePointerCancelListener);\n    if (isActiveElement(keyboardNode) && startEvent.pointerType === \"mouse\") {\n      startEvent.preventDefault();\n    }\n    startPress(startEvent);\n  };\n  const removePointerListener = addDomEvent(pointerNode, \"pointerdown\", startPointerPress, { passive: !onPressStart });\n  const removeFocusListener = addDomEvent(keyboardNode, \"focus\", startAccessiblePress);\n  removeStartListeners = pipe(removePointerListener, removeFocusListener);\n  function startAccessiblePress() {\n    const handleKeydown = (keydownEvent) => {\n      if (!isValidKey(keydownEvent)) return;\n      const handleKeyup = (keyupEvent) => {\n        if (!isValidKey(keyupEvent)) return;\n        const evt2 = new win.PointerEvent(\"pointerup\");\n        const info = getInfo(evt2);\n        onPress?.(info);\n        onPressEnd?.(info);\n      };\n      removeEndListeners();\n      removeEndListeners = addDomEvent(keyboardNode, \"keyup\", handleKeyup);\n      const evt = new win.PointerEvent(\"pointerdown\");\n      startPress(evt);\n    };\n    const handleBlur = () => {\n      const evt = new win.PointerEvent(\"pointercancel\");\n      cancelPress(evt);\n    };\n    const removeKeydownListener = addDomEvent(keyboardNode, \"keydown\", handleKeydown);\n    const removeBlurListener = addDomEvent(keyboardNode, \"blur\", handleBlur);\n    removeAccessibleListeners = pipe(removeKeydownListener, removeBlurListener);\n  }\n  return () => {\n    removeStartListeners();\n    removeEndListeners();\n    removeAccessibleListeners();\n  };\n}\n\n// src/proxy-tab-focus.ts\nfunction proxyTabFocusImpl(container, options = {}) {\n  const { triggerElement, onFocus, onFocusEnter, getShadowRoot } = options;\n  const doc = container?.ownerDocument || document;\n  const body = doc.body;\n  function onKeyDown(event) {\n    if (event.key !== \"Tab\") return;\n    let elementToFocus = null;\n    const [firstTabbable, lastTabbable] = getTabbableEdges(container, { includeContainer: true, getShadowRoot });\n    const nextTabbableAfterTrigger = getNextTabbable(body, { current: triggerElement, getShadowRoot });\n    const noTabbableElements = !firstTabbable && !lastTabbable;\n    if (event.shiftKey && isActiveElement(nextTabbableAfterTrigger)) {\n      onFocusEnter?.();\n      elementToFocus = lastTabbable;\n    } else if (event.shiftKey && (isActiveElement(firstTabbable) || noTabbableElements)) {\n      elementToFocus = triggerElement;\n    } else if (!event.shiftKey && isActiveElement(triggerElement)) {\n      onFocusEnter?.();\n      elementToFocus = firstTabbable;\n    } else if (!event.shiftKey && (isActiveElement(lastTabbable) || noTabbableElements)) {\n      elementToFocus = nextTabbableAfterTrigger;\n    }\n    if (!elementToFocus) return;\n    event.preventDefault();\n    if (typeof onFocus === \"function\") {\n      onFocus(elementToFocus);\n    } else {\n      elementToFocus.focus();\n    }\n  }\n  return addDomEvent(doc, \"keydown\", onKeyDown, true);\n}\nfunction proxyTabFocus(container, options) {\n  const { defer, triggerElement, ...restOptions } = options;\n  const func = defer ? raf : (v) => v();\n  const cleanups = [];\n  cleanups.push(\n    func(() => {\n      const node = typeof container === \"function\" ? container() : container;\n      const trigger = typeof triggerElement === \"function\" ? triggerElement() : triggerElement;\n      cleanups.push(proxyTabFocusImpl(node, { triggerElement: trigger, ...restOptions }));\n    })\n  );\n  return () => {\n    cleanups.forEach((fn) => fn?.());\n  };\n}\n\n// src/query.ts\nfunction queryAll(root, selector) {\n  return Array.from(root?.querySelectorAll(selector) ?? []);\n}\nfunction query(root, selector) {\n  return root?.querySelector(selector) ?? null;\n}\nvar defaultItemToId = (v) => v.id;\nfunction itemById(v, id, itemToId = defaultItemToId) {\n  return v.find((item) => itemToId(item) === id);\n}\nfunction indexOfId(v, id, itemToId = defaultItemToId) {\n  const item = itemById(v, id, itemToId);\n  return item ? v.indexOf(item) : -1;\n}\nfunction nextById(v, id, loop = true) {\n  let idx = indexOfId(v, id);\n  idx = loop ? (idx + 1) % v.length : Math.min(idx + 1, v.length - 1);\n  return v[idx];\n}\nfunction prevById(v, id, loop = true) {\n  let idx = indexOfId(v, id);\n  if (idx === -1) return loop ? v[v.length - 1] : null;\n  idx = loop ? (idx - 1 + v.length) % v.length : Math.max(0, idx - 1);\n  return v[idx];\n}\n\n// src/resize-observer.ts\nfunction createSharedResizeObserver(options) {\n  const listeners = /* @__PURE__ */ new WeakMap();\n  let observer;\n  const entries = /* @__PURE__ */ new WeakMap();\n  const getObserver = (win) => {\n    if (observer) return observer;\n    observer = new win.ResizeObserver((observedEntries) => {\n      for (const entry of observedEntries) {\n        entries.set(entry.target, entry);\n        const elementListeners = listeners.get(entry.target);\n        if (elementListeners) {\n          for (const listener of elementListeners) {\n            listener(entry);\n          }\n        }\n      }\n    });\n    return observer;\n  };\n  const observe = (element, listener) => {\n    let elementListeners = listeners.get(element) || /* @__PURE__ */ new Set();\n    elementListeners.add(listener);\n    listeners.set(element, elementListeners);\n    const win = getWindow(element);\n    getObserver(win).observe(element, options);\n    return () => {\n      const elementListeners2 = listeners.get(element);\n      if (!elementListeners2) return;\n      elementListeners2.delete(listener);\n      if (elementListeners2.size === 0) {\n        listeners.delete(element);\n        getObserver(win).unobserve(element);\n      }\n    };\n  };\n  const unobserve = (element) => {\n    listeners.delete(element);\n    observer?.unobserve(element);\n  };\n  return {\n    observe,\n    unobserve\n  };\n}\nvar resizeObserverContentBox = /* @__PURE__ */ createSharedResizeObserver({\n  box: \"content-box\"\n});\nvar resizeObserverBorderBox = /* @__PURE__ */ createSharedResizeObserver({\n  box: \"border-box\"\n});\nvar resizeObserverDevicePixelContentBox = /* @__PURE__ */ createSharedResizeObserver({\n  box: \"device-pixel-content-box\"\n});\n\n// src/scope.ts\nfunction createScope(methods) {\n  const dom = {\n    getRootNode: (ctx) => ctx.getRootNode?.() ?? document,\n    getDoc: (ctx) => getDocument(dom.getRootNode(ctx)),\n    getWin: (ctx) => dom.getDoc(ctx).defaultView ?? window,\n    getActiveElement: (ctx) => getActiveElement(dom.getRootNode(ctx)),\n    isActiveElement,\n    getById: (ctx, id) => dom.getRootNode(ctx).getElementById(id),\n    setValue: (elem, value) => {\n      if (elem == null || value == null) return;\n      setElementValue(elem, value.toString());\n    }\n  };\n  return { ...dom, ...methods };\n}\n\n// src/searchable.ts\nvar sanitize = (str) => str.split(\"\").map((char) => {\n  const code = char.charCodeAt(0);\n  if (code > 0 && code < 128) return char;\n  if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace(\"/\", \"\\\\\");\n  return \"\";\n}).join(\"\").trim();\nvar getValueText = (el) => {\n  return sanitize(el.dataset?.valuetext ?? el.textContent ?? \"\");\n};\nvar match = (valueText, query2) => {\n  return valueText.trim().toLowerCase().startsWith(query2.toLowerCase());\n};\nfunction getByText(v, text, currentId, itemToId = defaultItemToId) {\n  const index = currentId ? indexOfId(v, currentId, itemToId) : -1;\n  let items = currentId ? wrap(v, index) : v;\n  const isSingleKey = text.length === 1;\n  if (isSingleKey) {\n    items = items.filter((item) => itemToId(item) !== currentId);\n  }\n  return items.find((item) => match(getValueText(item), text));\n}\n\n// src/set.ts\nfunction setAttribute(el, attr, v) {\n  const prev = el.getAttribute(attr);\n  const exists = prev != null;\n  if (prev === v) return noop;\n  el.setAttribute(attr, v);\n  return () => {\n    if (!exists) {\n      el.removeAttribute(attr);\n    } else {\n      el.setAttribute(attr, prev);\n    }\n  };\n}\nfunction setProperty(el, prop, v) {\n  const exists = prop in el;\n  const prev = el[prop];\n  if (prev === v) return noop;\n  el[prop] = v;\n  return () => {\n    if (!exists) {\n      delete el[prop];\n    } else {\n      el[prop] = prev;\n    }\n  };\n}\nfunction setStyle(el, style) {\n  if (!el) return noop;\n  const prev = Object.keys(style).reduce((acc, key) => {\n    acc[key] = el.style.getPropertyValue(key);\n    return acc;\n  }, {});\n  if (isEqual(prev, style)) return noop;\n  Object.assign(el.style, style);\n  return () => {\n    Object.assign(el.style, prev);\n    if (el.style.length === 0) {\n      el.removeAttribute(\"style\");\n    }\n  };\n}\nfunction setStyleProperty(el, prop, value) {\n  if (!el) return noop;\n  const prev = el.style.getPropertyValue(prop);\n  if (prev === value) return noop;\n  el.style.setProperty(prop, value);\n  return () => {\n    el.style.setProperty(prop, prev);\n    if (el.style.length === 0) {\n      el.removeAttribute(\"style\");\n    }\n  };\n}\nfunction isEqual(a, b) {\n  return Object.keys(a).every((key) => a[key] === b[key]);\n}\n\n// src/typeahead.ts\nfunction getByTypeaheadImpl(baseItems, options) {\n  const { state: state2, activeId, key, timeout = 350, itemToId } = options;\n  const search = state2.keysSoFar + key;\n  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);\n  const query2 = isRepeated ? search[0] : search;\n  let items = baseItems.slice();\n  const next = getByText(items, query2, activeId, itemToId);\n  function cleanup() {\n    clearTimeout(state2.timer);\n    state2.timer = -1;\n  }\n  function update(value) {\n    state2.keysSoFar = value;\n    cleanup();\n    if (value !== \"\") {\n      state2.timer = +setTimeout(() => {\n        update(\"\");\n        cleanup();\n      }, timeout);\n    }\n  }\n  update(search);\n  return next;\n}\nvar getByTypeahead = /* @__PURE__ */ Object.assign(getByTypeaheadImpl, {\n  defaultOptions: { keysSoFar: \"\", timer: -1 },\n  isValidEvent: isValidTypeaheadEvent\n});\nfunction isValidTypeaheadEvent(event) {\n  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;\n}\n\n// src/visual-viewport.ts\nfunction trackVisualViewport(doc, fn) {\n  const win = doc?.defaultView || window;\n  const onResize = () => {\n    fn?.(getViewportSize(win));\n  };\n  onResize();\n  return addDomEvent(win.visualViewport ?? win, \"resize\", onResize);\n}\nfunction getViewportSize(win) {\n  return {\n    width: win.visualViewport?.width || win.innerWidth,\n    height: win.visualViewport?.height || win.innerHeight\n  };\n}\n\n// src/visually-hidden.ts\nvar visuallyHiddenStyle = {\n  border: \"0\",\n  clip: \"rect(0 0 0 0)\",\n  height: \"1px\",\n  margin: \"-1px\",\n  overflow: \"hidden\",\n  padding: \"0\",\n  position: \"absolute\",\n  width: \"1px\",\n  whiteSpace: \"nowrap\",\n  wordWrap: \"normal\"\n};\nfunction setVisuallyHidden(el) {\n  Object.assign(el.style, visuallyHiddenStyle);\n}\n\n// src/wait-for.ts\nfunction waitForPromise(promise, controller, timeout) {\n  const { signal } = controller;\n  const wrappedPromise = new Promise((resolve, reject) => {\n    const timeoutId = setTimeout(() => {\n      reject(new Error(`Timeout of ${timeout}ms exceeded`));\n    }, timeout);\n    signal.addEventListener(\"abort\", () => {\n      clearTimeout(timeoutId);\n      reject(new Error(\"Promise aborted\"));\n    });\n    promise.then((result) => {\n      if (!signal.aborted) {\n        clearTimeout(timeoutId);\n        resolve(result);\n      }\n    }).catch((error) => {\n      if (!signal.aborted) {\n        clearTimeout(timeoutId);\n        reject(error);\n      }\n    });\n  });\n  const abort = () => controller.abort();\n  return [wrappedPromise, abort];\n}\nfunction waitForElement(target, options) {\n  const { timeout, rootNode } = options;\n  const win = getWindow(rootNode);\n  const doc = getDocument(rootNode);\n  const controller = new win.AbortController();\n  return waitForPromise(\n    new Promise((resolve) => {\n      const el = target();\n      if (el) {\n        resolve(el);\n        return;\n      }\n      const observer = new win.MutationObserver(() => {\n        const el2 = target();\n        if (el2 && el2.isConnected) {\n          observer.disconnect();\n          resolve(el2);\n        }\n      });\n      observer.observe(doc.body, {\n        childList: true,\n        subtree: true\n      });\n    }),\n    controller,\n    timeout\n  );\n}\nfunction waitForEvent(target, event, options) {\n  let cleanup;\n  const { predicate, ...listenerOptions } = options ?? {};\n  const promise = new Promise((resolve) => {\n    const element = target?.();\n    if (!element) {\n      return;\n    }\n    const handler = (e) => {\n      if (!predicate || predicate(element)) {\n        resolve(e);\n        cleanup?.();\n      }\n    };\n    element.addEventListener(event, handler, listenerOptions);\n    cleanup = () => element.removeEventListener(event, handler, listenerOptions);\n  });\n  return [promise, () => cleanup?.()];\n}\n\nexport { AnimationFrame, MAX_Z_INDEX, addDomEvent, ariaAttr, clickIfLink, contains, createScope, dataAttr, defaultItemToId, disableTextSelection, dispatchInputCheckedEvent, dispatchInputValueEvent, findControlledElements, getActiveElement, getBeforeInputValue, getByText, getByTypeahead, getComputedStyle, getControlledElements, getDataUrl, getDocument, getDocumentElement, getEventKey, getEventPoint, getEventStep, getEventTarget, getFirstFocusable, getFirstTabbable, getFocusables, getInitialFocus, getLastTabbable, getNativeEvent, getNearestOverflowAncestor, getNextTabbable, getNodeName, getOverflowAncestors, getParentNode, getPlatform, getRelativePoint, getRootNode, getScrollPosition, getTabIndex, getTabbableEdges, getTabbables, getUserAgent, getWindow, hasControllerElements, indexOfId, isActiveElement, isAnchorElement, isAndroid, isApple, isCaretAtStart, isChrome, isComposingEvent, isContextMenuEvent, isControlledByExpandedController, isControlledElement, isControllerElement, isCtrlOrMetaKey, isDocument, isDom, isDownloadingEvent, isEditableElement, isElementVisible, isFirefox, isFocusable, isHTMLElement, isIPad, isIPhone, isInView, isInputElement, isInteractiveContainerElement, isIos, isKeyboardClick, isLeftClick, isMac, isModifierKey, isNode, isOpeningInNewTab, isOverflowElement, isPrintableKey, isRootElement, isSafari, isSelfTarget, isShadowRoot, isTabbable, isTouchDevice, isTouchEvent, isValidTabEvent, isVirtualClick, isVirtualPointerEvent, isVisualViewport, isWebKit, isWindow, itemById, navigate, nextById, nextTick, observeAttributes, observeChildren, prevById, proxyTabFocus, query, queryAll, queueBeforeEvent, raf, requestPointerLock, resizeObserverBorderBox, resizeObserverContentBox, resizeObserverDevicePixelContentBox, restoreTextSelection, scrollIntoView, setAttribute, setCaretToEnd, setElementChecked, setElementValue, setProperty, setStyle, setStyleProperty, setVisuallyHidden, trackFormControl, trackPointerMove, trackPress, trackVisualViewport, visuallyHiddenStyle, waitForElement, waitForEvent, waitForPromise };\n", "import { callAll, isEqual, isString } from '@zag-js/utils';\nimport { isActiveElement, getDocument, getActiveElement } from '@zag-js/dom-query';\n\n// src/merge-props.ts\nvar clsx = (...args) => args.map((str) => str?.trim?.()).filter(Boolean).join(\" \");\nvar CSS_REGEX = /((?:--)?(?:\\w+-?)+)\\s*:\\s*([^;]*)/g;\nvar serialize = (style) => {\n  const res = {};\n  let match;\n  while (match = CSS_REGEX.exec(style)) {\n    res[match[1]] = match[2];\n  }\n  return res;\n};\nvar css = (a, b) => {\n  if (isString(a)) {\n    if (isString(b)) return `${a};${b}`;\n    a = serialize(a);\n  } else if (isString(b)) {\n    b = serialize(b);\n  }\n  return Object.assign({}, a ?? {}, b ?? {});\n};\nfunction mergeProps(...args) {\n  let result = {};\n  for (let props of args) {\n    if (!props) continue;\n    for (let key in result) {\n      if (key.startsWith(\"on\") && typeof result[key] === \"function\" && typeof props[key] === \"function\") {\n        result[key] = callAll(props[key], result[key]);\n        continue;\n      }\n      if (key === \"className\" || key === \"class\") {\n        result[key] = clsx(result[key], props[key]);\n        continue;\n      }\n      if (key === \"style\") {\n        result[key] = css(result[key], props[key]);\n        continue;\n      }\n      result[key] = props[key] !== void 0 ? props[key] : result[key];\n    }\n    for (let key in props) {\n      if (result[key] === void 0) {\n        result[key] = props[key];\n      }\n    }\n    const symbols = Object.getOwnPropertySymbols(props);\n    for (let symbol of symbols) {\n      result[symbol] = props[symbol];\n    }\n  }\n  return result;\n}\nfunction memo(getDeps, fn, opts) {\n  let deps = [];\n  let result;\n  return (depArgs) => {\n    const newDeps = getDeps(depArgs);\n    const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index) => !isEqual(deps[index], dep));\n    if (!depsChanged) return result;\n    deps = newDeps;\n    result = fn(newDeps, depArgs);\n    opts?.onChange?.(result);\n    return result;\n  };\n}\n\n// src/create-machine.ts\nfunction createGuards() {\n  return {\n    and: (...guards) => {\n      return function andGuard(params) {\n        return guards.every((str) => params.guard(str));\n      };\n    },\n    or: (...guards) => {\n      return function orGuard(params) {\n        return guards.some((str) => params.guard(str));\n      };\n    },\n    not: (guard) => {\n      return function notGuard(params) {\n        return !params.guard(guard);\n      };\n    }\n  };\n}\nfunction createMachine(config) {\n  return config;\n}\nfunction setup() {\n  return {\n    guards: createGuards(),\n    createMachine: (config) => {\n      return createMachine(config);\n    },\n    choose: (transitions) => {\n      return function chooseFn({ choose }) {\n        return choose(transitions)?.actions;\n      };\n    }\n  };\n}\n\n// src/types.ts\nvar MachineStatus = /* @__PURE__ */ ((MachineStatus2) => {\n  MachineStatus2[\"NotStarted\"] = \"Not Started\";\n  MachineStatus2[\"Started\"] = \"Started\";\n  MachineStatus2[\"Stopped\"] = \"Stopped\";\n  return MachineStatus2;\n})(MachineStatus || {});\nvar INIT_STATE = \"__init__\";\nfunction createScope(props) {\n  const getRootNode = () => props.getRootNode?.() ?? document;\n  const getDoc = () => getDocument(getRootNode());\n  const getWin = () => getDoc().defaultView ?? window;\n  const getActiveElementFn = () => getActiveElement(getRootNode());\n  const getById = (id) => getRootNode().getElementById(id);\n  return {\n    ...props,\n    getRootNode,\n    getDoc,\n    getWin,\n    getActiveElement: getActiveElementFn,\n    isActiveElement,\n    getById\n  };\n}\n\nexport { INIT_STATE, MachineStatus, createGuards, createMachine, createScope, memo, mergeProps, setup };\n", "import { mergeProps } from '@zag-js/core';\nimport { memo, forwardRef, createElement, isValidElement, Children, cloneElement } from 'react';\nimport { composeRefs } from '../utils/compose-refs.js';\n\nfunction getRef(element) {\n  let getter = Object.getOwnPropertyDescriptor(element.props, \"ref\")?.get;\n  let mayWarn = getter && \"isReactWarning\" in getter && getter.isReactWarning;\n  if (mayWarn) {\n    return element.ref;\n  }\n  getter = Object.getOwnPropertyDescriptor(element, \"ref\")?.get;\n  mayWarn = getter && \"isReactWarning\" in getter && getter.isReactWarning;\n  if (mayWarn) {\n    return element.props.ref;\n  }\n  return element.props.ref || element.ref;\n}\nconst withAsChild = (Component) => {\n  const Comp = memo(\n    forwardRef((props, ref) => {\n      const { asChild, children, ...restProps } = props;\n      if (!asChild) {\n        return createElement(Component, { ...restProps, ref }, children);\n      }\n      if (!isValidElement(children)) {\n        return null;\n      }\n      const onlyChild = Children.only(children);\n      const childRef = getRef(onlyChild);\n      return cloneElement(onlyChild, {\n        ...mergeProps(restProps, onlyChild.props),\n        ref: ref ? composeRefs(ref, childRef) : childRef\n      });\n    })\n  );\n  Comp.displayName = Component.displayName || Component.name;\n  return Comp;\n};\nconst jsxFactory = () => {\n  const cache = /* @__PURE__ */ new Map();\n  return new Proxy(withAsChild, {\n    apply(_target, _thisArg, argArray) {\n      return withAsChild(argArray[0]);\n    },\n    get(_, element) {\n      const asElement = element;\n      if (!cache.has(asElement)) {\n        cache.set(asElement, withAsChild(asElement));\n      }\n      return cache.get(asElement);\n    }\n  });\n};\nconst ark = jsxFactory();\n\nexport { ark, jsxFactory };\n", "function composeRefs(...refs) {\n  return (node) => {\n    const cleanUps = [];\n    for (const ref of refs) {\n      if (typeof ref === \"function\") {\n        const cb = ref(node);\n        if (typeof cb === \"function\") {\n          cleanUps.push(cb);\n        }\n      } else if (ref) {\n        ref.current = node;\n      }\n    }\n    if (cleanUps.length) {\n      return () => {\n        for (const cleanUp of cleanUps) {\n          cleanUp();\n        }\n      };\n    }\n  };\n}\n\nexport { composeRefs };\n", "// src/create-anatomy.ts\nvar createAnatomy = (name, parts = []) => ({\n  parts: (...values) => {\n    if (isEmpty(parts)) {\n      return createAnatomy(name, values);\n    }\n    throw new Error(\"createAnatomy().parts(...) should only be called once. Did you mean to use .extendWith(...) ?\");\n  },\n  extendWith: (...values) => createAnatomy(name, [...parts, ...values]),\n  omit: (...values) => createAnatomy(name, parts.filter((part) => !values.includes(part))),\n  rename: (newName) => createAnatomy(newName, parts),\n  keys: () => parts,\n  build: () => [...new Set(parts)].reduce(\n    (prev, part) => Object.assign(prev, {\n      [part]: {\n        selector: [\n          `&[data-scope=\"${toKebabCase(name)}\"][data-part=\"${toKebabCase(part)}\"]`,\n          `& [data-scope=\"${toKebabCase(name)}\"][data-part=\"${toKebabCase(part)}\"]`\n        ].join(\", \"),\n        attrs: { \"data-scope\": toKebabCase(name), \"data-part\": toKebabCase(part) }\n      }\n    }),\n    {}\n  )\n});\nvar toKebabCase = (value) => value.replace(/([A-Z])([A-Z])/g, \"$1-$2\").replace(/([a-z])([A-Z])/g, \"$1-$2\").replace(/[\\s_]+/g, \"-\").toLowerCase();\nvar isEmpty = (v) => v.length === 0;\n\nexport { createAnatomy };\n", "var __defProp = Object.defineProperty;\nvar __typeError = (msg) => {\n  throw TypeError(msg);\n};\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n\n// src/array.ts\nfunction toArray(v) {\n  if (v == null) return [];\n  return Array.isArray(v) ? v : [v];\n}\nvar fromLength = (length) => Array.from(Array(length).keys());\nvar first = (v) => v[0];\nvar last = (v) => v[v.length - 1];\nvar isEmpty = (v) => v.length === 0;\nvar has = (v, t) => v.indexOf(t) !== -1;\nvar add = (v, ...items) => v.concat(items);\nvar remove = (v, ...items) => v.filter((t) => !items.includes(t));\nvar removeAt = (v, i) => v.filter((_, idx) => idx !== i);\nvar insertAt = (v, i, ...items) => [...v.slice(0, i), ...items, ...v.slice(i)];\nvar uniq = (v) => Array.from(new Set(v));\nvar diff = (a, b) => {\n  const set = new Set(b);\n  return a.filter((t) => !set.has(t));\n};\nvar addOrRemove = (v, item) => has(v, item) ? remove(v, item) : add(v, item);\nfunction clear(v) {\n  while (v.length > 0) v.pop();\n  return v;\n}\nfunction nextIndex(v, idx, opts = {}) {\n  const { step = 1, loop = true } = opts;\n  const next2 = idx + step;\n  const len = v.length;\n  const last2 = len - 1;\n  if (idx === -1) return step > 0 ? 0 : last2;\n  if (next2 < 0) return loop ? last2 : 0;\n  if (next2 >= len) return loop ? 0 : idx > len ? len : idx;\n  return next2;\n}\nfunction next(v, idx, opts = {}) {\n  return v[nextIndex(v, idx, opts)];\n}\nfunction prevIndex(v, idx, opts = {}) {\n  const { step = 1, loop = true } = opts;\n  return nextIndex(v, idx, { step: -step, loop });\n}\nfunction prev(v, index, opts = {}) {\n  return v[prevIndex(v, index, opts)];\n}\nfunction chunk(v, size) {\n  return v.reduce((rows, value, index) => {\n    if (index % size === 0) rows.push([value]);\n    else last(rows)?.push(value);\n    return rows;\n  }, []);\n}\nfunction flatArray(arr) {\n  return arr.reduce((flat, item) => {\n    if (Array.isArray(item)) {\n      return flat.concat(flatArray(item));\n    }\n    return flat.concat(item);\n  }, []);\n}\nfunction partition(arr, fn) {\n  return arr.reduce(\n    ([pass, fail], value) => {\n      if (fn(value)) pass.push(value);\n      else fail.push(value);\n      return [pass, fail];\n    },\n    [[], []]\n  );\n}\n\n// src/equal.ts\nvar isArrayLike = (value) => value?.constructor.name === \"Array\";\nvar isArrayEqual = (a, b) => {\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; i++) {\n    if (!isEqual(a[i], b[i])) return false;\n  }\n  return true;\n};\nvar isEqual = (a, b) => {\n  if (Object.is(a, b)) return true;\n  if (a == null && b != null || a != null && b == null) return false;\n  if (typeof a?.isEqual === \"function\" && typeof b?.isEqual === \"function\") {\n    return a.isEqual(b);\n  }\n  if (typeof a === \"function\" && typeof b === \"function\") {\n    return a.toString() === b.toString();\n  }\n  if (isArrayLike(a) && isArrayLike(b)) {\n    return isArrayEqual(Array.from(a), Array.from(b));\n  }\n  if (!(typeof a === \"object\") || !(typeof b === \"object\")) return false;\n  const keys = Object.keys(b ?? /* @__PURE__ */ Object.create(null));\n  const length = keys.length;\n  for (let i = 0; i < length; i++) {\n    const hasKey = Reflect.has(a, keys[i]);\n    if (!hasKey) return false;\n  }\n  for (let i = 0; i < length; i++) {\n    const key = keys[i];\n    if (!isEqual(a[key], b[key])) return false;\n  }\n  return true;\n};\n\n// src/guard.ts\nvar isDev = () => process.env.NODE_ENV !== \"production\";\nvar isArray = (v) => Array.isArray(v);\nvar isBoolean = (v) => v === true || v === false;\nvar isObjectLike = (v) => v != null && typeof v === \"object\";\nvar isObject = (v) => isObjectLike(v) && !isArray(v);\nvar isNumber = (v) => typeof v === \"number\" && !Number.isNaN(v);\nvar isString = (v) => typeof v === \"string\";\nvar isFunction = (v) => typeof v === \"function\";\nvar isNull = (v) => v == null;\nvar hasProp = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\nvar baseGetTag = (v) => Object.prototype.toString.call(v);\nvar fnToString = Function.prototype.toString;\nvar objectCtorString = fnToString.call(Object);\nvar isPlainObject = (v) => {\n  if (!isObjectLike(v) || baseGetTag(v) != \"[object Object]\" || isFrameworkElement(v)) return false;\n  const proto = Object.getPrototypeOf(v);\n  if (proto === null) return true;\n  const Ctor = hasProp(proto, \"constructor\") && proto.constructor;\n  return typeof Ctor == \"function\" && Ctor instanceof Ctor && fnToString.call(Ctor) == objectCtorString;\n};\nvar isReactElement = (x) => typeof x === \"object\" && x !== null && \"$$typeof\" in x && \"props\" in x;\nvar isVueElement = (x) => typeof x === \"object\" && x !== null && \"__v_isVNode\" in x;\nvar isFrameworkElement = (x) => isReactElement(x) || isVueElement(x);\n\n// src/functions.ts\nvar runIfFn = (v, ...a) => {\n  const res = typeof v === \"function\" ? v(...a) : v;\n  return res ?? void 0;\n};\nvar cast = (v) => v;\nvar identity = (v) => v();\nvar noop = () => {\n};\nvar callAll = (...fns) => (...a) => {\n  fns.forEach(function(fn) {\n    fn?.(...a);\n  });\n};\nvar uuid = /* @__PURE__ */ (() => {\n  let id = 0;\n  return () => {\n    id++;\n    return id.toString(36);\n  };\n})();\nfunction match(key, record, ...args) {\n  if (key in record) {\n    const fn = record[key];\n    return isFunction(fn) ? fn(...args) : fn;\n  }\n  const error = new Error(`No matching key: ${JSON.stringify(key)} in ${JSON.stringify(Object.keys(record))}`);\n  Error.captureStackTrace?.(error, match);\n  throw error;\n}\nvar tryCatch = (fn, fallback) => {\n  try {\n    return fn();\n  } catch (error) {\n    if (error instanceof Error) {\n      Error.captureStackTrace?.(error, tryCatch);\n    }\n    return fallback?.();\n  }\n};\nfunction throttle(fn, wait = 0) {\n  let lastCall = 0;\n  let timeout = null;\n  return ((...args) => {\n    const now = Date.now();\n    const timeSinceLastCall = now - lastCall;\n    if (timeSinceLastCall >= wait) {\n      if (timeout) {\n        clearTimeout(timeout);\n        timeout = null;\n      }\n      fn(...args);\n      lastCall = now;\n    } else if (!timeout) {\n      timeout = setTimeout(() => {\n        fn(...args);\n        lastCall = Date.now();\n        timeout = null;\n      }, wait - timeSinceLastCall);\n    }\n  });\n}\nfunction debounce(fn, wait = 0) {\n  let timeout = null;\n  return ((...args) => {\n    if (timeout) {\n      clearTimeout(timeout);\n      timeout = null;\n    }\n    timeout = setTimeout(() => {\n      fn(...args);\n    }, wait);\n  });\n}\nvar toChar = (code) => String.fromCharCode(code + (code > 25 ? 39 : 97));\nfunction toName(code) {\n  let name = \"\";\n  let x;\n  for (x = Math.abs(code); x > 52; x = x / 52 | 0) name = toChar(x % 52) + name;\n  return toChar(x % 52) + name;\n}\nfunction toPhash(h, x) {\n  let i = x.length;\n  while (i) h = h * 33 ^ x.charCodeAt(--i);\n  return h;\n}\nvar hash = (value) => toName(toPhash(5381, value) >>> 0);\n\n// src/number.ts\nvar { floor, abs, round, min, max, pow, sign } = Math;\nvar isNaN = (v) => Number.isNaN(v);\nvar nan = (v) => isNaN(v) ? 0 : v;\nvar mod = (v, m) => (v % m + m) % m;\nvar wrap = (v, vmax) => (v % vmax + vmax) % vmax;\nvar getMinValueAtIndex = (i, v, vmin) => i === 0 ? vmin : v[i - 1];\nvar getMaxValueAtIndex = (i, v, vmax) => i === v.length - 1 ? vmax : v[i + 1];\nvar isValueAtMax = (v, vmax) => nan(v) >= vmax;\nvar isValueAtMin = (v, vmin) => nan(v) <= vmin;\nvar isValueWithinRange = (v, vmin, vmax) => {\n  const value = nan(v);\n  const minCheck = vmin == null || value >= vmin;\n  const maxCheck = vmax == null || value <= vmax;\n  return minCheck && maxCheck;\n};\nvar roundValue = (v, vmin, step) => round((nan(v) - vmin) / step) * step + vmin;\nvar clampValue = (v, vmin, vmax) => min(max(nan(v), vmin), vmax);\nvar clampPercent = (v) => clampValue(v, 0, 1);\nvar getValuePercent = (v, vmin, vmax) => (nan(v) - vmin) / (vmax - vmin);\nvar getPercentValue = (p, vmin, vmax, step) => clampValue(roundValue(p * (vmax - vmin) + vmin, vmin, step), vmin, vmax);\nvar roundToStepPrecision = (v, step) => {\n  let rv = v;\n  let ss = step.toString();\n  let pi = ss.indexOf(\".\");\n  let p = pi >= 0 ? ss.length - pi : 0;\n  if (p > 0) {\n    let pw = pow(10, p);\n    rv = round(rv * pw) / pw;\n  }\n  return rv;\n};\nvar roundToDpr = (v, dpr) => typeof dpr === \"number\" ? floor(v * dpr + 0.5) / dpr : round(v);\nvar snapValueToStep = (v, vmin, vmax, step) => {\n  const min2 = vmin != null ? Number(vmin) : 0;\n  const max2 = Number(vmax);\n  const remainder = (v - min2) % step;\n  let snapped = abs(remainder) * 2 >= step ? v + sign(remainder) * (step - abs(remainder)) : v - remainder;\n  snapped = roundToStepPrecision(snapped, step);\n  if (!isNaN(min2) && snapped < min2) {\n    snapped = min2;\n  } else if (!isNaN(max2) && snapped > max2) {\n    const stepsInRange = floor((max2 - min2) / step);\n    const largestValidStep = min2 + stepsInRange * step;\n    snapped = stepsInRange <= 0 || largestValidStep < min2 ? max2 : largestValidStep;\n  }\n  return roundToStepPrecision(snapped, step);\n};\nvar setValueAtIndex = (vs, i, v) => {\n  if (vs[i] === v) return vs;\n  return [...vs.slice(0, i), v, ...vs.slice(i + 1)];\n};\nfunction getValueSetterAtIndex(index, ctx) {\n  const minValueAtIndex = getMinValueAtIndex(index, ctx.values, ctx.min);\n  const maxValueAtIndex = getMaxValueAtIndex(index, ctx.values, ctx.max);\n  let nextValues = ctx.values.slice();\n  return function setValue(value) {\n    let nextValue = snapValueToStep(value, minValueAtIndex, maxValueAtIndex, ctx.step);\n    nextValues = setValueAtIndex(nextValues, index, value);\n    nextValues[index] = nextValue;\n    return nextValues;\n  };\n}\nfunction getNextStepValue(index, ctx) {\n  const nextValue = ctx.values[index] + ctx.step;\n  return getValueSetterAtIndex(index, ctx)(nextValue);\n}\nfunction getPreviousStepValue(index, ctx) {\n  const nextValue = ctx.values[index] - ctx.step;\n  return getValueSetterAtIndex(index, ctx)(nextValue);\n}\nvar getClosestValueIndex = (vs, t) => {\n  let i = vs.findIndex((v) => t - v < 0);\n  if (i === 0) return i;\n  if (i === -1) return vs.length - 1;\n  let vLeft = vs[i - 1];\n  let vRight = vs[i];\n  if (abs(vLeft - t) < abs(vRight - t)) return i - 1;\n  return i;\n};\nvar getClosestValue = (vs, t) => vs[getClosestValueIndex(vs, t)];\nvar getValueRanges = (vs, vmin, vmax, gap) => vs.map((v, i) => ({\n  min: i === 0 ? vmin : vs[i - 1] + gap,\n  max: i === vs.length - 1 ? vmax : vs[i + 1] - gap,\n  value: v\n}));\nvar getValueTransformer = (va, vb) => {\n  const [a, b] = va;\n  const [c, d] = vb;\n  return (v) => a === b || c === d ? c : c + (d - c) / (b - a) * (v - a);\n};\nvar toFixedNumber = (v, d = 0, b = 10) => {\n  const pow2 = Math.pow(b, d);\n  return round(v * pow2) / pow2;\n};\nvar countDecimals = (value) => {\n  if (!Number.isFinite(value)) return 0;\n  let e = 1, p = 0;\n  while (Math.round(value * e) / e !== value) {\n    e *= 10;\n    p += 1;\n  }\n  return p;\n};\nvar decimalOp = (a, op, b) => {\n  let result = op === \"+\" ? a + b : a - b;\n  if (a % 1 !== 0 || b % 1 !== 0) {\n    const multiplier = 10 ** Math.max(countDecimals(a), countDecimals(b));\n    a = Math.round(a * multiplier);\n    b = Math.round(b * multiplier);\n    result = op === \"+\" ? a + b : a - b;\n    result /= multiplier;\n  }\n  return result;\n};\nvar incrementValue = (v, s) => decimalOp(nan(v), \"+\", s);\nvar decrementValue = (v, s) => decimalOp(nan(v), \"-\", s);\nvar toPx = (v) => typeof v === \"number\" ? `${v}px` : v;\n\n// src/object.ts\nfunction compact(obj) {\n  if (!isPlainObject(obj) || obj === void 0) return obj;\n  const keys = Reflect.ownKeys(obj).filter((key) => typeof key === \"string\");\n  const filtered = {};\n  for (const key of keys) {\n    const value = obj[key];\n    if (value !== void 0) {\n      filtered[key] = compact(value);\n    }\n  }\n  return filtered;\n}\nvar json = (v) => JSON.parse(JSON.stringify(v));\nfunction pick(obj, keys) {\n  const filtered = {};\n  for (const key of keys) {\n    const value = obj[key];\n    if (value !== void 0) {\n      filtered[key] = value;\n    }\n  }\n  return filtered;\n}\nfunction splitProps(props, keys) {\n  const rest = {};\n  const result = {};\n  const keySet = new Set(keys);\n  const ownKeys = Reflect.ownKeys(props);\n  for (const key of ownKeys) {\n    if (keySet.has(key)) {\n      result[key] = props[key];\n    } else {\n      rest[key] = props[key];\n    }\n  }\n  return [result, rest];\n}\nvar createSplitProps = (keys) => {\n  return function split(props) {\n    return splitProps(props, keys);\n  };\n};\nfunction omit(obj, keys) {\n  return createSplitProps(keys)(obj)[1];\n}\n\n// src/store.ts\nfunction createStore(initialState, compare = Object.is) {\n  let state = { ...initialState };\n  const listeners = /* @__PURE__ */ new Set();\n  const subscribe = (listener) => {\n    listeners.add(listener);\n    return () => listeners.delete(listener);\n  };\n  const publish = () => {\n    listeners.forEach((listener) => listener());\n  };\n  const get = (key) => {\n    return state[key];\n  };\n  const set = (key, value) => {\n    if (!compare(state[key], value)) {\n      state[key] = value;\n      publish();\n    }\n  };\n  const update = (updates) => {\n    let hasChanges = false;\n    for (const key in updates) {\n      const value = updates[key];\n      if (value !== void 0 && !compare(state[key], value)) {\n        state[key] = value;\n        hasChanges = true;\n      }\n    }\n    if (hasChanges) {\n      publish();\n    }\n  };\n  const snapshot = () => ({ ...state });\n  return {\n    subscribe,\n    get,\n    set,\n    update,\n    snapshot\n  };\n}\n\n// src/timers.ts\nvar currentTime = () => performance.now();\nvar _tick;\nvar Timer = class {\n  constructor(onTick) {\n    this.onTick = onTick;\n    __publicField(this, \"frameId\", null);\n    __publicField(this, \"pausedAtMs\", null);\n    __publicField(this, \"context\");\n    __publicField(this, \"cancelFrame\", () => {\n      if (this.frameId === null) return;\n      cancelAnimationFrame(this.frameId);\n      this.frameId = null;\n    });\n    __publicField(this, \"setStartMs\", (startMs) => {\n      this.context.startMs = startMs;\n    });\n    __publicField(this, \"start\", () => {\n      if (this.frameId !== null) return;\n      const now = currentTime();\n      if (this.pausedAtMs !== null) {\n        this.context.startMs += now - this.pausedAtMs;\n        this.pausedAtMs = null;\n      } else {\n        this.context.startMs = now;\n      }\n      this.frameId = requestAnimationFrame(__privateGet(this, _tick));\n    });\n    __publicField(this, \"pause\", () => {\n      if (this.frameId === null) return;\n      this.cancelFrame();\n      this.pausedAtMs = currentTime();\n    });\n    __publicField(this, \"stop\", () => {\n      if (this.frameId === null) return;\n      this.cancelFrame();\n      this.pausedAtMs = null;\n    });\n    __privateAdd(this, _tick, (now) => {\n      this.context.now = now;\n      this.context.deltaMs = now - this.context.startMs;\n      const shouldContinue = this.onTick(this.context);\n      if (shouldContinue === false) {\n        this.stop();\n        return;\n      }\n      this.frameId = requestAnimationFrame(__privateGet(this, _tick));\n    });\n    this.context = { now: 0, startMs: currentTime(), deltaMs: 0 };\n  }\n  get elapsedMs() {\n    if (this.pausedAtMs !== null) {\n      return this.pausedAtMs - this.context.startMs;\n    }\n    return currentTime() - this.context.startMs;\n  }\n};\n_tick = new WeakMap();\nfunction setRafInterval(fn, intervalMs) {\n  const timer = new Timer(({ now, deltaMs }) => {\n    if (deltaMs >= intervalMs) {\n      const startMs = intervalMs > 0 ? now - deltaMs % intervalMs : now;\n      timer.setStartMs(startMs);\n      fn({ startMs, deltaMs });\n    }\n  });\n  timer.start();\n  return () => timer.stop();\n}\nfunction setRafTimeout(fn, delayMs) {\n  const timer = new Timer(({ deltaMs }) => {\n    if (deltaMs >= delayMs) {\n      fn();\n      return false;\n    }\n  });\n  timer.start();\n  return () => timer.stop();\n}\n\n// src/warning.ts\nfunction warn(...a) {\n  const m = a.length === 1 ? a[0] : a[1];\n  const c = a.length === 2 ? a[0] : true;\n  if (c && process.env.NODE_ENV !== \"production\") {\n    console.warn(m);\n  }\n}\nfunction invariant(...a) {\n  const m = a.length === 1 ? a[0] : a[1];\n  const c = a.length === 2 ? a[0] : true;\n  if (c && process.env.NODE_ENV !== \"production\") {\n    throw new Error(m);\n  }\n}\nfunction ensure(c, m) {\n  if (c == null) throw new Error(m());\n}\nfunction ensureProps(props, keys, scope) {\n  let missingKeys = [];\n  for (const key of keys) {\n    if (props[key] == null) missingKeys.push(key);\n  }\n  if (missingKeys.length > 0)\n    throw new Error(`[zag-js${scope ? ` > ${scope}` : \"\"}] missing required props: ${missingKeys.join(\", \")}`);\n}\n\nexport { Timer, add, addOrRemove, callAll, cast, chunk, clampPercent, clampValue, clear, compact, createSplitProps, createStore, debounce, decrementValue, diff, ensure, ensureProps, first, flatArray, fromLength, getClosestValue, getClosestValueIndex, getMaxValueAtIndex, getMinValueAtIndex, getNextStepValue, getPercentValue, getPreviousStepValue, getValuePercent, getValueRanges, getValueSetterAtIndex, getValueTransformer, has, hasProp, hash, identity, incrementValue, insertAt, invariant, isArray, isBoolean, isDev, isEmpty, isEqual, isFunction, isNaN, isNull, isNumber, isObject, isObjectLike, isPlainObject, isString, isValueAtMax, isValueAtMin, isValueWithinRange, json, last, match, mod, nan, next, nextIndex, noop, omit, partition, pick, prev, prevIndex, remove, removeAt, roundToDpr, roundToStepPrecision, roundValue, runIfFn, setRafInterval, setRafTimeout, setValueAtIndex, snapValueToStep, splitProps, throttle, toArray, toFixedNumber, toPx, tryCatch, uniq, uuid, warn, wrap };\n", "import { getComputedStyle } from '@zag-js/dom-query';\n\n// src/index.ts\nvar getDirection = (element) => getComputedStyle(element).direction;\nfunction getScrollPadding(element) {\n  const style = getComputedStyle(element);\n  const rect = element.getBoundingClientRect();\n  let xBeforeRaw = style.getPropertyValue(\"scroll-padding-left\").replace(\"auto\", \"0px\");\n  let yBeforeRaw = style.getPropertyValue(\"scroll-padding-top\").replace(\"auto\", \"0px\");\n  let xAfterRaw = style.getPropertyValue(\"scroll-padding-right\").replace(\"auto\", \"0px\");\n  let yAfterRaw = style.getPropertyValue(\"scroll-padding-bottom\").replace(\"auto\", \"0px\");\n  function convert(raw, size) {\n    let n = parseFloat(raw);\n    if (/%/.test(raw)) {\n      n /= 100;\n      n *= size;\n    }\n    return Number.isNaN(n) ? 0 : n;\n  }\n  let xBefore = convert(xBeforeRaw, rect.width);\n  let yBefore = convert(yBeforeRaw, rect.height);\n  let xAfter = convert(xAfterRaw, rect.width);\n  let yAfter = convert(yAfterRaw, rect.height);\n  return {\n    x: { before: xBefore, after: xAfter },\n    y: { before: yBefore, after: yAfter }\n  };\n}\nfunction isRectIntersecting(a, b, axis = \"both\") {\n  return axis === \"x\" && a.right >= b.left && a.left <= b.right || axis === \"y\" && a.bottom >= b.top && a.top <= b.bottom || axis === \"both\" && a.right >= b.left && a.left <= b.right && a.bottom >= b.top && a.top <= b.bottom;\n}\nfunction getDescendants(parent) {\n  let children = [];\n  for (const child of parent.children) {\n    children = children.concat(child, getDescendants(child));\n  }\n  return children;\n}\nfunction getSnapPositions(parent, subtree = false) {\n  const parentRect = parent.getBoundingClientRect();\n  const dir = getDirection(parent);\n  const isRtl = dir === \"rtl\";\n  const positions = {\n    x: { start: [], center: [], end: [] },\n    y: { start: [], center: [], end: [] }\n  };\n  const children = subtree ? getDescendants(parent) : parent.children;\n  for (const axis of [\"x\", \"y\"]) {\n    const orthogonalAxis = axis === \"x\" ? \"y\" : \"x\";\n    const axisStart = axis === \"x\" ? \"left\" : \"top\";\n    const axisEnd = axis === \"x\" ? \"right\" : \"bottom\";\n    const axisSize = axis === \"x\" ? \"width\" : \"height\";\n    const axisScroll = axis === \"x\" ? \"scrollLeft\" : \"scrollTop\";\n    const useRtlCalc = isRtl && axis === \"x\";\n    for (const child of children) {\n      const childRect = child.getBoundingClientRect();\n      if (!isRectIntersecting(parentRect, childRect, orthogonalAxis)) {\n        continue;\n      }\n      const childStyle = getComputedStyle(child);\n      let [childAlignY, childAlignX] = childStyle.getPropertyValue(\"scroll-snap-align\").split(\" \");\n      if (typeof childAlignX === \"undefined\") {\n        childAlignX = childAlignY;\n      }\n      const childAlign = axis === \"x\" ? childAlignX : childAlignY;\n      let childOffsetStart;\n      let childOffsetEnd;\n      let childOffsetCenter;\n      if (useRtlCalc) {\n        const scrollOffset = Math.abs(parent[axisScroll]);\n        const rightOffset = parentRect[axisEnd] - childRect[axisEnd] + scrollOffset;\n        childOffsetStart = rightOffset;\n        childOffsetEnd = rightOffset + childRect[axisSize];\n        childOffsetCenter = rightOffset + childRect[axisSize] / 2;\n      } else {\n        childOffsetStart = childRect[axisStart] - parentRect[axisStart] + parent[axisScroll];\n        childOffsetEnd = childOffsetStart + childRect[axisSize];\n        childOffsetCenter = childOffsetStart + childRect[axisSize] / 2;\n      }\n      switch (childAlign) {\n        case \"none\":\n          break;\n        case \"start\":\n          positions[axis].start.push({ node: child, position: childOffsetStart });\n          break;\n        case \"center\":\n          positions[axis].center.push({ node: child, position: childOffsetCenter });\n          break;\n        case \"end\":\n          positions[axis].end.push({ node: child, position: childOffsetEnd });\n          break;\n      }\n    }\n  }\n  return positions;\n}\nfunction getScrollSnapPositions(element) {\n  const dir = getDirection(element);\n  const rect = element.getBoundingClientRect();\n  const scrollPadding = getScrollPadding(element);\n  const snapPositions = getSnapPositions(element);\n  const maxScroll = {\n    x: element.scrollWidth - element.offsetWidth,\n    y: element.scrollHeight - element.offsetHeight\n  };\n  const isRtl = dir === \"rtl\";\n  const usesNegativeScrollLeft = isRtl && element.scrollLeft <= 0;\n  let xPositions;\n  if (isRtl) {\n    xPositions = uniq(\n      [\n        ...snapPositions.x.start.map((v) => v.position - scrollPadding.x.after),\n        ...snapPositions.x.center.map((v) => v.position - rect.width / 2),\n        ...snapPositions.x.end.map((v) => v.position - rect.width + scrollPadding.x.before)\n      ].map(clamp(0, maxScroll.x))\n    );\n    if (usesNegativeScrollLeft) {\n      xPositions = xPositions.map((pos) => -pos);\n    }\n  } else {\n    xPositions = uniq(\n      [\n        ...snapPositions.x.start.map((v) => v.position - scrollPadding.x.before),\n        ...snapPositions.x.center.map((v) => v.position - rect.width / 2),\n        ...snapPositions.x.end.map((v) => v.position - rect.width + scrollPadding.x.after)\n      ].map(clamp(0, maxScroll.x))\n    );\n  }\n  return {\n    x: xPositions,\n    y: uniq(\n      [\n        ...snapPositions.y.start.map((v) => v.position - scrollPadding.y.before),\n        ...snapPositions.y.center.map((v) => v.position - rect.height / 2),\n        ...snapPositions.y.end.map((v) => v.position - rect.height + scrollPadding.y.after)\n      ].map(clamp(0, maxScroll.y))\n    )\n  };\n}\nfunction findSnapPoint(parent, axis, predicate) {\n  const dir = getDirection(parent);\n  const scrollPadding = getScrollPadding(parent);\n  const snapPositions = getSnapPositions(parent);\n  const items = [...snapPositions[axis].start, ...snapPositions[axis].center, ...snapPositions[axis].end];\n  const isRtl = dir === \"rtl\";\n  const usesNegativeScrollLeft = isRtl && axis === \"x\" && parent.scrollLeft <= 0;\n  for (const item of items) {\n    if (predicate(item.node)) {\n      let position;\n      if (axis === \"x\" && isRtl) {\n        position = item.position - scrollPadding.x.after;\n        if (usesNegativeScrollLeft) {\n          position = -position;\n        }\n      } else {\n        position = item.position - (axis === \"x\" ? scrollPadding.x.before : scrollPadding.y.before);\n      }\n      return position;\n    }\n  }\n}\nfunction getSnapPointTarget(parent, snapPoint) {\n  const rect = parent.getBoundingClientRect();\n  const scrollPadding = getScrollPadding(parent);\n  const children = Array.from(parent.children);\n  for (const child of children) {\n    const childRect = child.getBoundingClientRect();\n    const childOffsetStart = {\n      x: childRect.left - rect.left + parent.scrollLeft,\n      y: childRect.top - rect.top + parent.scrollTop\n    };\n    const matchesX = [\n      childOffsetStart.x - scrollPadding.x.before,\n      // start\n      childOffsetStart.x + childRect.width / 2 - rect.width / 2,\n      // center\n      childOffsetStart.x + childRect.width - rect.width + scrollPadding.x.after\n      // end\n    ].some((pos) => Math.abs(pos - snapPoint) < 1);\n    const matchesY = [\n      childOffsetStart.y - scrollPadding.y.before,\n      childOffsetStart.y + childRect.height / 2 - rect.height / 2,\n      childOffsetStart.y + childRect.height - rect.height + scrollPadding.y.after\n    ].some((pos) => Math.abs(pos - snapPoint) < 1);\n    if (matchesX || matchesY) {\n      return child;\n    }\n  }\n  return children[0];\n}\nvar uniq = (arr) => [...new Set(arr)];\nvar clamp = (min, max) => (value) => Math.max(min, Math.min(max, value));\n\nexport { findSnapPoint, getScrollSnapPositions, getSnapPointTarget, getSnapPositions };\n", "// src/prop-types.ts\nfunction createNormalizer(fn) {\n  return new Proxy({}, {\n    get(_target, key) {\n      if (key === \"style\")\n        return (props) => {\n          return fn({ style: props }).style;\n        };\n      return fn;\n    }\n  });\n}\n\n// src/create-props.ts\nvar createProps = () => (props) => Array.from(new Set(props));\n\nexport { createNormalizer, createProps };\n", "import { createAnatomy } from '@zag-js/anatomy';\nimport { raf, addDomEvent, trackPointerMove, resizeObserverBorderBox, queryAll, getTabbables, dataAttr, getEventKey, ariaAttr, isLeftClick, getEventTarget, isFocusable, contains } from '@zag-js/dom-query';\nimport { clampValue, prevIndex, nextIndex, add, remove, uniq, callAll, isObject, ensureProps, createSplitProps, throttle } from '@zag-js/utils';\nimport { createMachine } from '@zag-js/core';\nimport { getScrollSnapPositions, findSnapPoint } from '@zag-js/scroll-snap';\nimport { createProps } from '@zag-js/types';\n\n// src/carousel.anatomy.ts\nvar anatomy = createAnatomy(\"carousel\").parts(\n  \"root\",\n  \"itemGroup\",\n  \"item\",\n  \"control\",\n  \"nextTrigger\",\n  \"prevTrigger\",\n  \"indicatorGroup\",\n  \"indicator\",\n  \"autoplayTrigger\",\n  \"progressText\"\n);\nvar parts = anatomy.build();\nvar getRootId = (ctx) => ctx.ids?.root ?? `carousel:${ctx.id}`;\nvar getItemId = (ctx, index) => ctx.ids?.item?.(index) ?? `carousel:${ctx.id}:item:${index}`;\nvar getItemGroupId = (ctx) => ctx.ids?.itemGroup ?? `carousel:${ctx.id}:item-group`;\nvar getNextTriggerId = (ctx) => ctx.ids?.nextTrigger ?? `carousel:${ctx.id}:next-trigger`;\nvar getPrevTriggerId = (ctx) => ctx.ids?.prevTrigger ?? `carousel:${ctx.id}:prev-trigger`;\nvar getIndicatorGroupId = (ctx) => ctx.ids?.indicatorGroup ?? `carousel:${ctx.id}:indicator-group`;\nvar getIndicatorId = (ctx, index) => ctx.ids?.indicator?.(index) ?? `carousel:${ctx.id}:indicator:${index}`;\nvar getItemGroupEl = (ctx) => ctx.getById(getItemGroupId(ctx));\nvar getItemEls = (ctx) => queryAll(getItemGroupEl(ctx), `[data-part=item]`);\nvar getIndicatorEl = (ctx, page) => ctx.getById(getIndicatorId(ctx, page));\nvar syncTabIndex = (ctx) => {\n  const el = getItemGroupEl(ctx);\n  if (!el) return;\n  const tabbables = getTabbables(el);\n  el.setAttribute(\"tabindex\", tabbables.length > 0 ? \"-1\" : \"0\");\n};\n\n// src/carousel.connect.ts\nfunction connect(service, normalize) {\n  const { state, context, computed, send, scope, prop } = service;\n  const isPlaying = state.matches(\"autoplay\");\n  const isDragging = state.matches(\"dragging\");\n  const canScrollNext = computed(\"canScrollNext\");\n  const canScrollPrev = computed(\"canScrollPrev\");\n  const horizontal = computed(\"isHorizontal\");\n  const autoSize = prop(\"autoSize\");\n  const pageSnapPoints = Array.from(context.get(\"pageSnapPoints\"));\n  const page = context.get(\"page\");\n  const slidesPerPage = prop(\"slidesPerPage\");\n  const padding = prop(\"padding\");\n  const translations = prop(\"translations\");\n  return {\n    isPlaying,\n    isDragging,\n    page,\n    pageSnapPoints,\n    canScrollNext,\n    canScrollPrev,\n    getProgress() {\n      return page / pageSnapPoints.length;\n    },\n    getProgressText() {\n      const details = { page: page + 1, totalPages: pageSnapPoints.length };\n      return translations.progressText?.(details) ?? \"\";\n    },\n    scrollToIndex(index, instant) {\n      send({ type: \"INDEX.SET\", index, instant });\n    },\n    scrollTo(index, instant) {\n      send({ type: \"PAGE.SET\", index, instant });\n    },\n    scrollNext(instant) {\n      send({ type: \"PAGE.NEXT\", instant });\n    },\n    scrollPrev(instant) {\n      send({ type: \"PAGE.PREV\", instant });\n    },\n    play() {\n      send({ type: \"AUTOPLAY.START\" });\n    },\n    pause() {\n      send({ type: \"AUTOPLAY.PAUSE\" });\n    },\n    isInView(index) {\n      return Array.from(context.get(\"slidesInView\")).includes(index);\n    },\n    refresh() {\n      send({ type: \"SNAP.REFRESH\" });\n    },\n    getRootProps() {\n      return normalize.element({\n        ...parts.root.attrs,\n        id: getRootId(scope),\n        role: \"region\",\n        \"aria-roledescription\": \"carousel\",\n        \"data-orientation\": prop(\"orientation\"),\n        dir: prop(\"dir\"),\n        style: {\n          \"--slides-per-page\": slidesPerPage,\n          \"--slide-spacing\": prop(\"spacing\"),\n          \"--slide-item-size\": autoSize ? \"auto\" : \"calc(100% / var(--slides-per-page) - var(--slide-spacing) * (var(--slides-per-page) - 1) / var(--slides-per-page))\"\n        }\n      });\n    },\n    getItemGroupProps() {\n      return normalize.element({\n        ...parts.itemGroup.attrs,\n        id: getItemGroupId(scope),\n        \"data-orientation\": prop(\"orientation\"),\n        \"data-dragging\": dataAttr(isDragging),\n        dir: prop(\"dir\"),\n        \"aria-live\": isPlaying ? \"off\" : \"polite\",\n        onFocus(event) {\n          if (!contains(event.currentTarget, getEventTarget(event))) return;\n          send({ type: \"VIEWPORT.FOCUS\" });\n        },\n        onBlur(event) {\n          if (contains(event.currentTarget, event.relatedTarget)) return;\n          send({ type: \"VIEWPORT.BLUR\" });\n        },\n        onMouseDown(event) {\n          if (event.defaultPrevented) return;\n          if (!prop(\"allowMouseDrag\")) return;\n          if (!isLeftClick(event)) return;\n          const target = getEventTarget(event);\n          if (isFocusable(target) && target !== event.currentTarget) return;\n          event.preventDefault();\n          send({ type: \"DRAGGING.START\" });\n        },\n        onWheel: throttle((event) => {\n          const axis = prop(\"orientation\") === \"horizontal\" ? \"deltaX\" : \"deltaY\";\n          const isScrollingLeft = event[axis] < 0;\n          if (isScrollingLeft && !computed(\"canScrollPrev\")) return;\n          const isScrollingRight = event[axis] > 0;\n          if (isScrollingRight && !computed(\"canScrollNext\")) return;\n          send({ type: \"USER.SCROLL\" });\n        }, 150),\n        onTouchStart() {\n          send({ type: \"USER.SCROLL\" });\n        },\n        style: {\n          display: autoSize ? \"flex\" : \"grid\",\n          gap: \"var(--slide-spacing)\",\n          scrollSnapType: [horizontal ? \"x\" : \"y\", prop(\"snapType\")].join(\" \"),\n          gridAutoFlow: horizontal ? \"column\" : \"row\",\n          scrollbarWidth: \"none\",\n          overscrollBehaviorX: \"contain\",\n          [horizontal ? \"gridAutoColumns\" : \"gridAutoRows\"]: autoSize ? void 0 : \"var(--slide-item-size)\",\n          [horizontal ? \"scrollPaddingInline\" : \"scrollPaddingBlock\"]: padding,\n          [horizontal ? \"paddingInline\" : \"paddingBlock\"]: padding,\n          [horizontal ? \"overflowX\" : \"overflowY\"]: \"auto\"\n        }\n      });\n    },\n    getItemProps(props2) {\n      const isInView = context.get(\"slidesInView\").includes(props2.index);\n      return normalize.element({\n        ...parts.item.attrs,\n        id: getItemId(scope, props2.index),\n        dir: prop(\"dir\"),\n        role: \"group\",\n        \"data-index\": props2.index,\n        \"data-inview\": dataAttr(isInView),\n        \"aria-roledescription\": \"slide\",\n        \"data-orientation\": prop(\"orientation\"),\n        \"aria-label\": translations.item(props2.index, prop(\"slideCount\")),\n        \"aria-hidden\": ariaAttr(!isInView),\n        style: {\n          flex: \"0 0 auto\",\n          [horizontal ? \"maxWidth\" : \"maxHeight\"]: \"100%\",\n          scrollSnapAlign: (() => {\n            const snapAlign = props2.snapAlign ?? \"start\";\n            const slidesPerMove = prop(\"slidesPerMove\");\n            const perMove = slidesPerMove === \"auto\" ? Math.floor(prop(\"slidesPerPage\")) : slidesPerMove;\n            const shouldSnap = (props2.index + perMove) % perMove === 0;\n            return shouldSnap ? snapAlign : void 0;\n          })()\n        }\n      });\n    },\n    getControlProps() {\n      return normalize.element({\n        ...parts.control.attrs,\n        \"data-orientation\": prop(\"orientation\")\n      });\n    },\n    getPrevTriggerProps() {\n      return normalize.button({\n        ...parts.prevTrigger.attrs,\n        id: getPrevTriggerId(scope),\n        type: \"button\",\n        disabled: !canScrollPrev,\n        dir: prop(\"dir\"),\n        \"aria-label\": translations.prevTrigger,\n        \"data-orientation\": prop(\"orientation\"),\n        \"aria-controls\": getItemGroupId(scope),\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          send({ type: \"PAGE.PREV\", src: \"trigger\" });\n        }\n      });\n    },\n    getNextTriggerProps() {\n      return normalize.button({\n        ...parts.nextTrigger.attrs,\n        dir: prop(\"dir\"),\n        id: getNextTriggerId(scope),\n        type: \"button\",\n        \"aria-label\": translations.nextTrigger,\n        \"data-orientation\": prop(\"orientation\"),\n        \"aria-controls\": getItemGroupId(scope),\n        disabled: !canScrollNext,\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          send({ type: \"PAGE.NEXT\", src: \"trigger\" });\n        }\n      });\n    },\n    getIndicatorGroupProps() {\n      return normalize.element({\n        ...parts.indicatorGroup.attrs,\n        dir: prop(\"dir\"),\n        id: getIndicatorGroupId(scope),\n        \"data-orientation\": prop(\"orientation\"),\n        onKeyDown(event) {\n          if (event.defaultPrevented) return;\n          const src = \"indicator\";\n          const keyMap = {\n            ArrowDown(event2) {\n              if (horizontal) return;\n              send({ type: \"PAGE.NEXT\", src });\n              event2.preventDefault();\n            },\n            ArrowUp(event2) {\n              if (horizontal) return;\n              send({ type: \"PAGE.PREV\", src });\n              event2.preventDefault();\n            },\n            ArrowRight(event2) {\n              if (!horizontal) return;\n              send({ type: \"PAGE.NEXT\", src });\n              event2.preventDefault();\n            },\n            ArrowLeft(event2) {\n              if (!horizontal) return;\n              send({ type: \"PAGE.PREV\", src });\n              event2.preventDefault();\n            },\n            Home(event2) {\n              send({ type: \"PAGE.SET\", index: 0, src });\n              event2.preventDefault();\n            },\n            End(event2) {\n              send({ type: \"PAGE.SET\", index: pageSnapPoints.length - 1, src });\n              event2.preventDefault();\n            }\n          };\n          const key = getEventKey(event, {\n            dir: prop(\"dir\"),\n            orientation: prop(\"orientation\")\n          });\n          const exec = keyMap[key];\n          exec?.(event);\n        }\n      });\n    },\n    getIndicatorProps(props2) {\n      return normalize.button({\n        ...parts.indicator.attrs,\n        dir: prop(\"dir\"),\n        id: getIndicatorId(scope, props2.index),\n        type: \"button\",\n        \"data-orientation\": prop(\"orientation\"),\n        \"data-index\": props2.index,\n        \"data-readonly\": dataAttr(props2.readOnly),\n        \"data-current\": dataAttr(props2.index === page),\n        \"aria-label\": translations.indicator(props2.index),\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          if (props2.readOnly) return;\n          send({ type: \"PAGE.SET\", index: props2.index, src: \"indicator\" });\n        }\n      });\n    },\n    getAutoplayTriggerProps() {\n      return normalize.button({\n        ...parts.autoplayTrigger.attrs,\n        type: \"button\",\n        \"data-orientation\": prop(\"orientation\"),\n        \"data-pressed\": dataAttr(isPlaying),\n        \"aria-label\": isPlaying ? translations.autoplayStop : translations.autoplayStart,\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          send({ type: isPlaying ? \"AUTOPLAY.PAUSE\" : \"AUTOPLAY.START\" });\n        }\n      });\n    },\n    getProgressTextProps() {\n      return normalize.element({\n        ...parts.progressText.attrs\n      });\n    }\n  };\n}\nvar machine = createMachine({\n  props({ props: props2 }) {\n    ensureProps(props2, [\"slideCount\"], \"carousel\");\n    return {\n      dir: \"ltr\",\n      defaultPage: 0,\n      orientation: \"horizontal\",\n      snapType: \"mandatory\",\n      loop: !!props2.autoplay,\n      slidesPerPage: 1,\n      slidesPerMove: \"auto\",\n      spacing: \"0px\",\n      autoplay: false,\n      allowMouseDrag: false,\n      inViewThreshold: 0.6,\n      autoSize: false,\n      ...props2,\n      translations: {\n        nextTrigger: \"Next slide\",\n        prevTrigger: \"Previous slide\",\n        indicator: (index) => `Go to slide ${index + 1}`,\n        item: (index, count) => `${index + 1} of ${count}`,\n        autoplayStart: \"Start slide rotation\",\n        autoplayStop: \"Stop slide rotation\",\n        progressText: ({ page, totalPages }) => `${page} / ${totalPages}`,\n        ...props2.translations\n      }\n    };\n  },\n  refs() {\n    return {\n      timeoutRef: void 0\n    };\n  },\n  initialState({ prop }) {\n    return prop(\"autoplay\") ? \"autoplay\" : \"idle\";\n  },\n  context({ prop, bindable, getContext }) {\n    return {\n      page: bindable(() => ({\n        defaultValue: prop(\"defaultPage\"),\n        value: prop(\"page\"),\n        onChange(page) {\n          const ctx = getContext();\n          const pageSnapPoints = ctx.get(\"pageSnapPoints\");\n          prop(\"onPageChange\")?.({ page, pageSnapPoint: pageSnapPoints[page] });\n        }\n      })),\n      pageSnapPoints: bindable(() => {\n        return {\n          defaultValue: prop(\"autoSize\") ? Array.from({ length: prop(\"slideCount\") }, (_, i) => i) : getPageSnapPoints(prop(\"slideCount\"), prop(\"slidesPerMove\"), prop(\"slidesPerPage\"))\n        };\n      }),\n      slidesInView: bindable(() => ({\n        defaultValue: []\n      }))\n    };\n  },\n  computed: {\n    isRtl: ({ prop }) => prop(\"dir\") === \"rtl\",\n    isHorizontal: ({ prop }) => prop(\"orientation\") === \"horizontal\",\n    canScrollNext: ({ prop, context }) => prop(\"loop\") || context.get(\"page\") < context.get(\"pageSnapPoints\").length - 1,\n    canScrollPrev: ({ prop, context }) => prop(\"loop\") || context.get(\"page\") > 0,\n    autoplayInterval: ({ prop }) => {\n      const autoplay = prop(\"autoplay\");\n      return isObject(autoplay) ? autoplay.delay : 4e3;\n    }\n  },\n  watch({ track, action, context, prop, send }) {\n    track([() => prop(\"slidesPerPage\"), () => prop(\"slidesPerMove\")], () => {\n      action([\"setSnapPoints\"]);\n    });\n    track([() => context.get(\"page\")], () => {\n      action([\"scrollToPage\", \"focusIndicatorEl\"]);\n    });\n    track([() => prop(\"orientation\"), () => prop(\"autoSize\"), () => prop(\"dir\")], () => {\n      action([\"setSnapPoints\", \"scrollToPage\"]);\n    });\n    track([() => prop(\"slideCount\")], () => {\n      send({ type: \"SNAP.REFRESH\", src: \"slide.count\" });\n    });\n    track([() => !!prop(\"autoplay\")], () => {\n      send({ type: prop(\"autoplay\") ? \"AUTOPLAY.START\" : \"AUTOPLAY.PAUSE\", src: \"autoplay.prop.change\" });\n    });\n  },\n  on: {\n    \"PAGE.NEXT\": {\n      target: \"idle\",\n      actions: [\"clearScrollEndTimer\", \"setNextPage\"]\n    },\n    \"PAGE.PREV\": {\n      target: \"idle\",\n      actions: [\"clearScrollEndTimer\", \"setPrevPage\"]\n    },\n    \"PAGE.SET\": {\n      target: \"idle\",\n      actions: [\"clearScrollEndTimer\", \"setPage\"]\n    },\n    \"INDEX.SET\": {\n      target: \"idle\",\n      actions: [\"clearScrollEndTimer\", \"setMatchingPage\"]\n    },\n    \"SNAP.REFRESH\": {\n      actions: [\"setSnapPoints\", \"clampPage\"]\n    },\n    \"PAGE.SCROLL\": {\n      actions: [\"scrollToPage\"]\n    }\n  },\n  effects: [\"trackSlideMutation\", \"trackSlideIntersections\", \"trackSlideResize\"],\n  entry: [\"setSnapPoints\", \"setPage\"],\n  exit: [\"clearScrollEndTimer\"],\n  states: {\n    idle: {\n      on: {\n        \"DRAGGING.START\": {\n          target: \"dragging\",\n          actions: [\"invokeDragStart\"]\n        },\n        \"AUTOPLAY.START\": {\n          target: \"autoplay\",\n          actions: [\"invokeAutoplayStart\"]\n        },\n        \"USER.SCROLL\": {\n          target: \"userScroll\"\n        },\n        \"VIEWPORT.FOCUS\": {\n          target: \"focus\"\n        }\n      }\n    },\n    focus: {\n      effects: [\"trackKeyboardScroll\"],\n      on: {\n        \"VIEWPORT.BLUR\": {\n          target: \"idle\"\n        },\n        \"PAGE.NEXT\": {\n          actions: [\"clearScrollEndTimer\", \"setNextPage\"]\n        },\n        \"PAGE.PREV\": {\n          actions: [\"clearScrollEndTimer\", \"setPrevPage\"]\n        },\n        \"PAGE.SET\": {\n          actions: [\"clearScrollEndTimer\", \"setPage\"]\n        },\n        \"INDEX.SET\": {\n          actions: [\"clearScrollEndTimer\", \"setMatchingPage\"]\n        },\n        \"USER.SCROLL\": {\n          target: \"userScroll\"\n        }\n      }\n    },\n    dragging: {\n      effects: [\"trackPointerMove\"],\n      entry: [\"disableScrollSnap\"],\n      on: {\n        DRAGGING: {\n          actions: [\"scrollSlides\", \"invokeDragging\"]\n        },\n        \"DRAGGING.END\": {\n          target: \"idle\",\n          actions: [\"endDragging\", \"invokeDraggingEnd\"]\n        }\n      }\n    },\n    userScroll: {\n      effects: [\"trackScroll\"],\n      on: {\n        \"DRAGGING.START\": {\n          target: \"dragging\",\n          actions: [\"invokeDragStart\"]\n        },\n        \"SCROLL.END\": [\n          {\n            guard: \"isFocused\",\n            target: \"focus\",\n            actions: [\"setClosestPage\"]\n          },\n          {\n            target: \"idle\",\n            actions: [\"setClosestPage\"]\n          }\n        ]\n      }\n    },\n    autoplay: {\n      effects: [\"trackDocumentVisibility\", \"trackScroll\", \"autoUpdateSlide\"],\n      exit: [\"invokeAutoplayEnd\"],\n      on: {\n        \"AUTOPLAY.TICK\": {\n          actions: [\"setNextPage\", \"invokeAutoplay\"]\n        },\n        \"DRAGGING.START\": {\n          target: \"dragging\",\n          actions: [\"invokeDragStart\"]\n        },\n        \"AUTOPLAY.PAUSE\": {\n          target: \"idle\"\n        }\n      }\n    }\n  },\n  implementations: {\n    guards: {\n      isFocused: ({ scope }) => scope.isActiveElement(getItemGroupEl(scope))\n    },\n    effects: {\n      autoUpdateSlide({ computed, send }) {\n        const id = setInterval(() => {\n          send({\n            type: computed(\"canScrollNext\") ? \"AUTOPLAY.TICK\" : \"AUTOPLAY.PAUSE\",\n            src: \"autoplay.interval\"\n          });\n        }, computed(\"autoplayInterval\"));\n        return () => clearInterval(id);\n      },\n      trackSlideMutation({ scope, send }) {\n        const el = getItemGroupEl(scope);\n        if (!el) return;\n        const win = scope.getWin();\n        const observer = new win.MutationObserver(() => {\n          send({ type: \"SNAP.REFRESH\", src: \"slide.mutation\" });\n          syncTabIndex(scope);\n        });\n        syncTabIndex(scope);\n        observer.observe(el, { childList: true, subtree: true });\n        return () => observer.disconnect();\n      },\n      trackSlideResize({ scope, send }) {\n        const el = getItemGroupEl(scope);\n        if (!el) return;\n        const exec = () => {\n          send({ type: \"SNAP.REFRESH\", src: \"slide.resize\" });\n        };\n        raf(() => {\n          exec();\n          raf(() => {\n            send({ type: \"PAGE.SCROLL\", instant: true });\n          });\n        });\n        const itemEls = getItemEls(scope);\n        itemEls.forEach(exec);\n        const cleanups = itemEls.map((el2) => resizeObserverBorderBox.observe(el2, exec));\n        return callAll(...cleanups);\n      },\n      trackSlideIntersections({ scope, prop, context }) {\n        const el = getItemGroupEl(scope);\n        const win = scope.getWin();\n        const observer = new win.IntersectionObserver(\n          (entries) => {\n            const slidesInView = entries.reduce((acc, entry) => {\n              const target = entry.target;\n              const index = Number(target.dataset.index ?? \"-1\");\n              if (index == null || Number.isNaN(index) || index === -1) return acc;\n              return entry.isIntersecting ? add(acc, index) : remove(acc, index);\n            }, context.get(\"slidesInView\"));\n            context.set(\"slidesInView\", uniq(slidesInView));\n          },\n          {\n            root: el,\n            threshold: prop(\"inViewThreshold\")\n          }\n        );\n        getItemEls(scope).forEach((slide) => observer.observe(slide));\n        return () => observer.disconnect();\n      },\n      trackScroll({ send, refs, scope }) {\n        const el = getItemGroupEl(scope);\n        if (!el) return;\n        const onScroll = () => {\n          clearTimeout(refs.get(\"timeoutRef\"));\n          refs.set(\"timeoutRef\", void 0);\n          refs.set(\n            \"timeoutRef\",\n            setTimeout(() => {\n              send({ type: \"SCROLL.END\" });\n            }, 150)\n          );\n        };\n        return addDomEvent(el, \"scroll\", onScroll, { passive: true });\n      },\n      trackDocumentVisibility({ scope, send }) {\n        const doc = scope.getDoc();\n        const onVisibilityChange = () => {\n          if (doc.visibilityState === \"visible\") return;\n          send({ type: \"AUTOPLAY.PAUSE\", src: \"doc.hidden\" });\n        };\n        return addDomEvent(doc, \"visibilitychange\", onVisibilityChange);\n      },\n      trackPointerMove({ scope, send }) {\n        const doc = scope.getDoc();\n        return trackPointerMove(doc, {\n          onPointerMove({ event }) {\n            send({ type: \"DRAGGING\", left: -event.movementX, top: -event.movementY });\n          },\n          onPointerUp() {\n            send({ type: \"DRAGGING.END\" });\n          }\n        });\n      },\n      trackKeyboardScroll({ scope, send, context }) {\n        const win = scope.getWin();\n        const onKeyDown = (event) => {\n          switch (event.key) {\n            case \"ArrowRight\":\n              event.preventDefault();\n              send({ type: \"PAGE.NEXT\" });\n              break;\n            case \"ArrowLeft\":\n              event.preventDefault();\n              send({ type: \"PAGE.PREV\" });\n              break;\n            case \"Home\":\n              event.preventDefault();\n              send({ type: \"PAGE.SET\", index: 0 });\n              break;\n            case \"End\":\n              event.preventDefault();\n              send({ type: \"PAGE.SET\", index: context.get(\"pageSnapPoints\").length - 1 });\n          }\n        };\n        return addDomEvent(win, \"keydown\", onKeyDown, { capture: true });\n      }\n    },\n    actions: {\n      clearScrollEndTimer({ refs }) {\n        if (refs.get(\"timeoutRef\") == null) return;\n        clearTimeout(refs.get(\"timeoutRef\"));\n        refs.set(\"timeoutRef\", void 0);\n      },\n      scrollToPage({ context, event, scope, computed, flush }) {\n        const behavior = event.instant ? \"instant\" : \"smooth\";\n        const index = clampValue(event.index ?? context.get(\"page\"), 0, context.get(\"pageSnapPoints\").length - 1);\n        const el = getItemGroupEl(scope);\n        if (!el) return;\n        const axis = computed(\"isHorizontal\") ? \"left\" : \"top\";\n        flush(() => {\n          el.scrollTo({ [axis]: context.get(\"pageSnapPoints\")[index], behavior });\n        });\n      },\n      setClosestPage({ context, scope, computed }) {\n        const el = getItemGroupEl(scope);\n        if (!el) return;\n        const scrollPosition = computed(\"isHorizontal\") ? el.scrollLeft : el.scrollTop;\n        const page = context.get(\"pageSnapPoints\").findIndex((point) => Math.abs(point - scrollPosition) < 1);\n        if (page === -1) return;\n        context.set(\"page\", page);\n      },\n      setNextPage({ context, prop, state }) {\n        const loop = state.matches(\"autoplay\") || prop(\"loop\");\n        const page = nextIndex(context.get(\"pageSnapPoints\"), context.get(\"page\"), { loop });\n        context.set(\"page\", page);\n      },\n      setPrevPage({ context, prop, state }) {\n        const loop = state.matches(\"autoplay\") || prop(\"loop\");\n        const page = prevIndex(context.get(\"pageSnapPoints\"), context.get(\"page\"), { loop });\n        context.set(\"page\", page);\n      },\n      setMatchingPage({ context, event, computed, scope }) {\n        const el = getItemGroupEl(scope);\n        if (!el) return;\n        const snapPoint = findSnapPoint(\n          el,\n          computed(\"isHorizontal\") ? \"x\" : \"y\",\n          (node) => node.dataset.index === event.index.toString()\n        );\n        if (snapPoint == null) return;\n        const page = context.get(\"pageSnapPoints\").findIndex((point) => Math.abs(point - snapPoint) < 1);\n        context.set(\"page\", page);\n      },\n      setPage({ context, event }) {\n        const page = event.index ?? context.get(\"page\");\n        context.set(\"page\", page);\n      },\n      clampPage({ context }) {\n        const index = clampValue(context.get(\"page\"), 0, context.get(\"pageSnapPoints\").length - 1);\n        context.set(\"page\", index);\n      },\n      setSnapPoints({ context, computed, scope }) {\n        const el = getItemGroupEl(scope);\n        if (!el) return;\n        const scrollSnapPoints = getScrollSnapPositions(el);\n        context.set(\"pageSnapPoints\", computed(\"isHorizontal\") ? scrollSnapPoints.x : scrollSnapPoints.y);\n      },\n      disableScrollSnap({ scope }) {\n        const el = getItemGroupEl(scope);\n        if (!el) return;\n        const styles = getComputedStyle(el);\n        el.dataset.scrollSnapType = styles.getPropertyValue(\"scroll-snap-type\");\n        el.style.setProperty(\"scroll-snap-type\", \"none\");\n      },\n      scrollSlides({ scope, event }) {\n        const el = getItemGroupEl(scope);\n        el?.scrollBy({ left: event.left, top: event.top, behavior: \"instant\" });\n      },\n      endDragging({ scope, context, computed }) {\n        const el = getItemGroupEl(scope);\n        if (!el) return;\n        const isHorizontal = computed(\"isHorizontal\");\n        const scrollPos = isHorizontal ? el.scrollLeft : el.scrollTop;\n        const snapPoints = context.get(\"pageSnapPoints\");\n        const closest = snapPoints.reduce((closest2, curr) => {\n          return Math.abs(curr - scrollPos) < Math.abs(closest2 - scrollPos) ? curr : closest2;\n        }, snapPoints[0]);\n        raf(() => {\n          el.scrollTo({\n            left: isHorizontal ? closest : el.scrollLeft,\n            top: isHorizontal ? el.scrollTop : closest,\n            behavior: \"smooth\"\n          });\n          context.set(\"page\", snapPoints.indexOf(closest));\n          const scrollSnapType = el.dataset.scrollSnapType;\n          if (scrollSnapType) {\n            el.style.setProperty(\"scroll-snap-type\", scrollSnapType);\n            delete el.dataset.scrollSnapType;\n          }\n        });\n      },\n      focusIndicatorEl({ context, event, scope }) {\n        if (event.src !== \"indicator\") return;\n        const el = getIndicatorEl(scope, context.get(\"page\"));\n        if (!el) return;\n        raf(() => el.focus({ preventScroll: true }));\n      },\n      invokeDragStart({ context, prop }) {\n        prop(\"onDragStatusChange\")?.({ type: \"dragging.start\", isDragging: true, page: context.get(\"page\") });\n      },\n      invokeDragging({ context, prop }) {\n        prop(\"onDragStatusChange\")?.({ type: \"dragging\", isDragging: true, page: context.get(\"page\") });\n      },\n      invokeDraggingEnd({ context, prop }) {\n        prop(\"onDragStatusChange\")?.({ type: \"dragging.end\", isDragging: false, page: context.get(\"page\") });\n      },\n      invokeAutoplay({ context, prop }) {\n        prop(\"onAutoplayStatusChange\")?.({ type: \"autoplay\", isPlaying: true, page: context.get(\"page\") });\n      },\n      invokeAutoplayStart({ context, prop }) {\n        prop(\"onAutoplayStatusChange\")?.({ type: \"autoplay.start\", isPlaying: true, page: context.get(\"page\") });\n      },\n      invokeAutoplayEnd({ context, prop }) {\n        prop(\"onAutoplayStatusChange\")?.({ type: \"autoplay.stop\", isPlaying: false, page: context.get(\"page\") });\n      }\n    }\n  }\n});\nfunction getPageSnapPoints(totalSlides, slidesPerMove, slidesPerPage) {\n  if (totalSlides == null || slidesPerPage <= 0) {\n    return [];\n  }\n  const snapPoints = [];\n  const perMove = slidesPerMove === \"auto\" ? Math.floor(slidesPerPage) : slidesPerMove;\n  if (perMove <= 0) {\n    return [];\n  }\n  for (let i = 0; i < totalSlides; i += perMove) {\n    if (i + slidesPerPage > totalSlides) break;\n    snapPoints.push(i);\n  }\n  return snapPoints;\n}\nvar props = createProps()([\n  \"dir\",\n  \"getRootNode\",\n  \"id\",\n  \"ids\",\n  \"loop\",\n  \"page\",\n  \"defaultPage\",\n  \"onPageChange\",\n  \"orientation\",\n  \"slideCount\",\n  \"slidesPerPage\",\n  \"slidesPerMove\",\n  \"spacing\",\n  \"padding\",\n  \"autoplay\",\n  \"allowMouseDrag\",\n  \"inViewThreshold\",\n  \"translations\",\n  \"snapType\",\n  \"autoSize\",\n  \"onDragStatusChange\",\n  \"onAutoplayStatusChange\"\n]);\nvar splitProps = createSplitProps(props);\nvar indicatorProps = createProps()([\"index\", \"readOnly\"]);\nvar splitIndicatorProps = createSplitProps(indicatorProps);\nvar itemProps = createProps()([\"index\", \"snapAlign\"]);\nvar splitItemProps = createSplitProps(itemProps);\n\nexport { anatomy, connect, indicatorProps, itemProps, machine, props, splitIndicatorProps, splitItemProps, splitProps };\n", "'use client';\nimport { anatomy } from '@zag-js/carousel';\n\nconst carouselAnatomy = anatomy.extendWith(\"progressText\", \"autoplayIndicator\");\n\nexport { carouselAnatomy };\n", "'use client';\nimport { hasProp, isFunction } from '@zag-js/utils';\nimport { createContext as createContext$1, useContext } from 'react';\n\nfunction getErrorMessage(hook, provider) {\n  return `${hook} returned \\`undefined\\`. Seems you forgot to wrap component within ${provider}`;\n}\nfunction createContext(options = {}) {\n  const {\n    name,\n    strict = true,\n    hookName = \"useContext\",\n    providerName = \"Provider\",\n    errorMessage,\n    defaultValue\n  } = options;\n  const Context = createContext$1(defaultValue);\n  Context.displayName = name;\n  function useContext$1() {\n    const context = useContext(Context);\n    if (!context && strict) {\n      const error = new Error(errorMessage ?? getErrorMessage(hookName, providerName));\n      error.name = \"ContextError\";\n      if (hasProp(Error, \"captureStackTrace\") && isFunction(Error.captureStackTrace)) {\n        Error.captureStackTrace(error, useContext$1);\n      }\n      throw error;\n    }\n    return context;\n  }\n  return [Context.Provider, useContext$1, Context];\n}\n\nexport { createContext };\n", "'use client';\nimport { createContext } from '../../utils/create-context.js';\n\nconst [CarouselProvider, useCarouselContext] = createContext({\n  name: \"CarouselContext\",\n  hookName: \"useCarouselContext\",\n  providerName: \"<CarouselProvider />\"\n});\n\nexport { CarouselProvider, useCarouselContext };\n", "'use client';\nimport { jsx } from 'react/jsx-runtime';\nimport { forwardRef, useMemo } from 'react';\nimport { ark } from '../factory.js';\nimport { carouselAnatomy } from './carousel.anatomy.js';\nimport { useCarouselContext } from './use-carousel-context.js';\n\nconst parts = carouselAnatomy.build();\nconst CarouselProgressText = forwardRef((props, ref) => {\n  const carousel = useCarouselContext();\n  const progressText = useMemo(() => {\n    const currentPage = carousel.page + 1;\n    const totalPages = carousel.pageSnapPoints.length;\n    return `${currentPage} / ${totalPages}`;\n  }, [carousel.page, carousel.pageSnapPoints.length]);\n  return /* @__PURE__ */ jsx(ark.span, { ref, ...parts.progressText.attrs, ...props, children: props.children || progressText });\n});\nCarouselProgressText.displayName = \"CarouselProgressText\";\n\nexport { CarouselProgressText };\n", "'use client';\nimport { jsx } from 'react/jsx-runtime';\nimport { mergeProps } from '@zag-js/react';\nimport { forwardRef } from 'react';\nimport { ark } from '../factory.js';\nimport { useCarouselContext } from './use-carousel-context.js';\n\nconst CarouselAutoplayTrigger = forwardRef((props, ref) => {\n  const carousel = useCarouselContext();\n  const mergedProps = mergeProps(carousel.getAutoplayTriggerProps(), props);\n  return /* @__PURE__ */ jsx(ark.button, { ...mergedProps, ref });\n});\nCarouselAutoplayTrigger.displayName = \"CarouselAutoplayTrigger\";\n\nexport { CarouselAutoplayTrigger };\n", "var __defProp = Object.defineProperty;\nvar __typeError = (msg) => {\n  throw TypeError(msg);\n};\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n\n// src/array.ts\nfunction toArray(v) {\n  if (v == null) return [];\n  return Array.isArray(v) ? v : [v];\n}\nvar fromLength = (length) => Array.from(Array(length).keys());\nvar first = (v) => v[0];\nvar last = (v) => v[v.length - 1];\nvar isEmpty = (v) => v.length === 0;\nvar has = (v, t) => v.indexOf(t) !== -1;\nvar add = (v, ...items) => v.concat(items);\nvar remove = (v, ...items) => v.filter((t) => !items.includes(t));\nvar removeAt = (v, i) => v.filter((_, idx) => idx !== i);\nvar insertAt = (v, i, ...items) => [...v.slice(0, i), ...items, ...v.slice(i)];\nvar uniq = (v) => Array.from(new Set(v));\nvar diff = (a, b) => {\n  const set = new Set(b);\n  return a.filter((t) => !set.has(t));\n};\nvar addOrRemove = (v, item) => has(v, item) ? remove(v, item) : add(v, item);\nfunction clear(v) {\n  while (v.length > 0) v.pop();\n  return v;\n}\nfunction nextIndex(v, idx, opts = {}) {\n  const { step = 1, loop = true } = opts;\n  const next2 = idx + step;\n  const len = v.length;\n  const last2 = len - 1;\n  if (idx === -1) return step > 0 ? 0 : last2;\n  if (next2 < 0) return loop ? last2 : 0;\n  if (next2 >= len) return loop ? 0 : idx > len ? len : idx;\n  return next2;\n}\nfunction next(v, idx, opts = {}) {\n  return v[nextIndex(v, idx, opts)];\n}\nfunction prevIndex(v, idx, opts = {}) {\n  const { step = 1, loop = true } = opts;\n  return nextIndex(v, idx, { step: -step, loop });\n}\nfunction prev(v, index, opts = {}) {\n  return v[prevIndex(v, index, opts)];\n}\nfunction chunk(v, size) {\n  return v.reduce((rows, value, index) => {\n    if (index % size === 0) rows.push([value]);\n    else last(rows)?.push(value);\n    return rows;\n  }, []);\n}\nfunction flatArray(arr) {\n  return arr.reduce((flat, item) => {\n    if (Array.isArray(item)) {\n      return flat.concat(flatArray(item));\n    }\n    return flat.concat(item);\n  }, []);\n}\nfunction partition(arr, fn) {\n  return arr.reduce(\n    ([pass, fail], value) => {\n      if (fn(value)) pass.push(value);\n      else fail.push(value);\n      return [pass, fail];\n    },\n    [[], []]\n  );\n}\n\n// src/equal.ts\nvar isArrayLike = (value) => value?.constructor.name === \"Array\";\nvar isArrayEqual = (a, b) => {\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; i++) {\n    if (!isEqual(a[i], b[i])) return false;\n  }\n  return true;\n};\nvar isEqual = (a, b) => {\n  if (Object.is(a, b)) return true;\n  if (a == null && b != null || a != null && b == null) return false;\n  if (typeof a?.isEqual === \"function\" && typeof b?.isEqual === \"function\") {\n    return a.isEqual(b);\n  }\n  if (typeof a === \"function\" && typeof b === \"function\") {\n    return a.toString() === b.toString();\n  }\n  if (isArrayLike(a) && isArrayLike(b)) {\n    return isArrayEqual(Array.from(a), Array.from(b));\n  }\n  if (!(typeof a === \"object\") || !(typeof b === \"object\")) return false;\n  const keys = Object.keys(b ?? /* @__PURE__ */ Object.create(null));\n  const length = keys.length;\n  for (let i = 0; i < length; i++) {\n    const hasKey = Reflect.has(a, keys[i]);\n    if (!hasKey) return false;\n  }\n  for (let i = 0; i < length; i++) {\n    const key = keys[i];\n    if (!isEqual(a[key], b[key])) return false;\n  }\n  return true;\n};\n\n// src/guard.ts\nvar isDev = () => process.env.NODE_ENV !== \"production\";\nvar isArray = (v) => Array.isArray(v);\nvar isBoolean = (v) => v === true || v === false;\nvar isObjectLike = (v) => v != null && typeof v === \"object\";\nvar isObject = (v) => isObjectLike(v) && !isArray(v);\nvar isNumber = (v) => typeof v === \"number\" && !Number.isNaN(v);\nvar isString = (v) => typeof v === \"string\";\nvar isFunction = (v) => typeof v === \"function\";\nvar isNull = (v) => v == null;\nvar hasProp = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\nvar baseGetTag = (v) => Object.prototype.toString.call(v);\nvar fnToString = Function.prototype.toString;\nvar objectCtorString = fnToString.call(Object);\nvar isPlainObject = (v) => {\n  if (!isObjectLike(v) || baseGetTag(v) != \"[object Object]\" || isFrameworkElement(v)) return false;\n  const proto = Object.getPrototypeOf(v);\n  if (proto === null) return true;\n  const Ctor = hasProp(proto, \"constructor\") && proto.constructor;\n  return typeof Ctor == \"function\" && Ctor instanceof Ctor && fnToString.call(Ctor) == objectCtorString;\n};\nvar isReactElement = (x) => typeof x === \"object\" && x !== null && \"$$typeof\" in x && \"props\" in x;\nvar isVueElement = (x) => typeof x === \"object\" && x !== null && \"__v_isVNode\" in x;\nvar isFrameworkElement = (x) => isReactElement(x) || isVueElement(x);\n\n// src/functions.ts\nvar runIfFn = (v, ...a) => {\n  const res = typeof v === \"function\" ? v(...a) : v;\n  return res ?? void 0;\n};\nvar cast = (v) => v;\nvar identity = (v) => v();\nvar noop = () => {\n};\nvar callAll = (...fns) => (...a) => {\n  fns.forEach(function(fn) {\n    fn?.(...a);\n  });\n};\nvar uuid = /* @__PURE__ */ (() => {\n  let id = 0;\n  return () => {\n    id++;\n    return id.toString(36);\n  };\n})();\nfunction match(key, record, ...args) {\n  if (key in record) {\n    const fn = record[key];\n    return isFunction(fn) ? fn(...args) : fn;\n  }\n  const error = new Error(`No matching key: ${JSON.stringify(key)} in ${JSON.stringify(Object.keys(record))}`);\n  Error.captureStackTrace?.(error, match);\n  throw error;\n}\nvar tryCatch = (fn, fallback) => {\n  try {\n    return fn();\n  } catch (error) {\n    if (error instanceof Error) {\n      Error.captureStackTrace?.(error, tryCatch);\n    }\n    return fallback?.();\n  }\n};\nfunction throttle(fn, wait = 0) {\n  let lastCall = 0;\n  let timeout = null;\n  return ((...args) => {\n    const now = Date.now();\n    const timeSinceLastCall = now - lastCall;\n    if (timeSinceLastCall >= wait) {\n      if (timeout) {\n        clearTimeout(timeout);\n        timeout = null;\n      }\n      fn(...args);\n      lastCall = now;\n    } else if (!timeout) {\n      timeout = setTimeout(() => {\n        fn(...args);\n        lastCall = Date.now();\n        timeout = null;\n      }, wait - timeSinceLastCall);\n    }\n  });\n}\nfunction debounce(fn, wait = 0) {\n  let timeout = null;\n  return ((...args) => {\n    if (timeout) {\n      clearTimeout(timeout);\n      timeout = null;\n    }\n    timeout = setTimeout(() => {\n      fn(...args);\n    }, wait);\n  });\n}\nvar toChar = (code) => String.fromCharCode(code + (code > 25 ? 39 : 97));\nfunction toName(code) {\n  let name = \"\";\n  let x;\n  for (x = Math.abs(code); x > 52; x = x / 52 | 0) name = toChar(x % 52) + name;\n  return toChar(x % 52) + name;\n}\nfunction toPhash(h, x) {\n  let i = x.length;\n  while (i) h = h * 33 ^ x.charCodeAt(--i);\n  return h;\n}\nvar hash = (value) => toName(toPhash(5381, value) >>> 0);\n\n// src/number.ts\nvar { floor, abs, round, min, max, pow, sign } = Math;\nvar isNaN = (v) => Number.isNaN(v);\nvar nan = (v) => isNaN(v) ? 0 : v;\nvar mod = (v, m) => (v % m + m) % m;\nvar wrap = (v, vmax) => (v % vmax + vmax) % vmax;\nvar getMinValueAtIndex = (i, v, vmin) => i === 0 ? vmin : v[i - 1];\nvar getMaxValueAtIndex = (i, v, vmax) => i === v.length - 1 ? vmax : v[i + 1];\nvar isValueAtMax = (v, vmax) => nan(v) >= vmax;\nvar isValueAtMin = (v, vmin) => nan(v) <= vmin;\nvar isValueWithinRange = (v, vmin, vmax) => {\n  const value = nan(v);\n  const minCheck = vmin == null || value >= vmin;\n  const maxCheck = vmax == null || value <= vmax;\n  return minCheck && maxCheck;\n};\nvar roundValue = (v, vmin, step) => round((nan(v) - vmin) / step) * step + vmin;\nvar clampValue = (v, vmin, vmax) => min(max(nan(v), vmin), vmax);\nvar clampPercent = (v) => clampValue(v, 0, 1);\nvar getValuePercent = (v, vmin, vmax) => (nan(v) - vmin) / (vmax - vmin);\nvar getPercentValue = (p, vmin, vmax, step) => clampValue(roundValue(p * (vmax - vmin) + vmin, vmin, step), vmin, vmax);\nvar roundToStepPrecision = (v, step) => {\n  let rv = v;\n  let ss = step.toString();\n  let pi = ss.indexOf(\".\");\n  let p = pi >= 0 ? ss.length - pi : 0;\n  if (p > 0) {\n    let pw = pow(10, p);\n    rv = round(rv * pw) / pw;\n  }\n  return rv;\n};\nvar roundToDpr = (v, dpr) => typeof dpr === \"number\" ? floor(v * dpr + 0.5) / dpr : round(v);\nvar snapValueToStep = (v, vmin, vmax, step) => {\n  const min2 = vmin != null ? Number(vmin) : 0;\n  const max2 = Number(vmax);\n  const remainder = (v - min2) % step;\n  let snapped = abs(remainder) * 2 >= step ? v + sign(remainder) * (step - abs(remainder)) : v - remainder;\n  snapped = roundToStepPrecision(snapped, step);\n  if (!isNaN(min2) && snapped < min2) {\n    snapped = min2;\n  } else if (!isNaN(max2) && snapped > max2) {\n    const stepsInRange = floor((max2 - min2) / step);\n    const largestValidStep = min2 + stepsInRange * step;\n    snapped = stepsInRange <= 0 || largestValidStep < min2 ? max2 : largestValidStep;\n  }\n  return roundToStepPrecision(snapped, step);\n};\nvar setValueAtIndex = (vs, i, v) => {\n  if (vs[i] === v) return vs;\n  return [...vs.slice(0, i), v, ...vs.slice(i + 1)];\n};\nfunction getValueSetterAtIndex(index, ctx) {\n  const minValueAtIndex = getMinValueAtIndex(index, ctx.values, ctx.min);\n  const maxValueAtIndex = getMaxValueAtIndex(index, ctx.values, ctx.max);\n  let nextValues = ctx.values.slice();\n  return function setValue(value) {\n    let nextValue = snapValueToStep(value, minValueAtIndex, maxValueAtIndex, ctx.step);\n    nextValues = setValueAtIndex(nextValues, index, value);\n    nextValues[index] = nextValue;\n    return nextValues;\n  };\n}\nfunction getNextStepValue(index, ctx) {\n  const nextValue = ctx.values[index] + ctx.step;\n  return getValueSetterAtIndex(index, ctx)(nextValue);\n}\nfunction getPreviousStepValue(index, ctx) {\n  const nextValue = ctx.values[index] - ctx.step;\n  return getValueSetterAtIndex(index, ctx)(nextValue);\n}\nvar getClosestValueIndex = (vs, t) => {\n  let i = vs.findIndex((v) => t - v < 0);\n  if (i === 0) return i;\n  if (i === -1) return vs.length - 1;\n  let vLeft = vs[i - 1];\n  let vRight = vs[i];\n  if (abs(vLeft - t) < abs(vRight - t)) return i - 1;\n  return i;\n};\nvar getClosestValue = (vs, t) => vs[getClosestValueIndex(vs, t)];\nvar getValueRanges = (vs, vmin, vmax, gap) => vs.map((v, i) => ({\n  min: i === 0 ? vmin : vs[i - 1] + gap,\n  max: i === vs.length - 1 ? vmax : vs[i + 1] - gap,\n  value: v\n}));\nvar getValueTransformer = (va, vb) => {\n  const [a, b] = va;\n  const [c, d] = vb;\n  return (v) => a === b || c === d ? c : c + (d - c) / (b - a) * (v - a);\n};\nvar toFixedNumber = (v, d = 0, b = 10) => {\n  const pow2 = Math.pow(b, d);\n  return round(v * pow2) / pow2;\n};\nvar countDecimals = (value) => {\n  if (!Number.isFinite(value)) return 0;\n  let e = 1, p = 0;\n  while (Math.round(value * e) / e !== value) {\n    e *= 10;\n    p += 1;\n  }\n  return p;\n};\nvar decimalOp = (a, op, b) => {\n  let result = op === \"+\" ? a + b : a - b;\n  if (a % 1 !== 0 || b % 1 !== 0) {\n    const multiplier = 10 ** Math.max(countDecimals(a), countDecimals(b));\n    a = Math.round(a * multiplier);\n    b = Math.round(b * multiplier);\n    result = op === \"+\" ? a + b : a - b;\n    result /= multiplier;\n  }\n  return result;\n};\nvar incrementValue = (v, s) => decimalOp(nan(v), \"+\", s);\nvar decrementValue = (v, s) => decimalOp(nan(v), \"-\", s);\nvar toPx = (v) => typeof v === \"number\" ? `${v}px` : v;\n\n// src/object.ts\nfunction compact(obj) {\n  if (!isPlainObject(obj) || obj === void 0) return obj;\n  const keys = Reflect.ownKeys(obj).filter((key) => typeof key === \"string\");\n  const filtered = {};\n  for (const key of keys) {\n    const value = obj[key];\n    if (value !== void 0) {\n      filtered[key] = compact(value);\n    }\n  }\n  return filtered;\n}\nvar json = (v) => JSON.parse(JSON.stringify(v));\nfunction pick(obj, keys) {\n  const filtered = {};\n  for (const key of keys) {\n    const value = obj[key];\n    if (value !== void 0) {\n      filtered[key] = value;\n    }\n  }\n  return filtered;\n}\nfunction splitProps(props, keys) {\n  const rest = {};\n  const result = {};\n  const keySet = new Set(keys);\n  const ownKeys = Reflect.ownKeys(props);\n  for (const key of ownKeys) {\n    if (keySet.has(key)) {\n      result[key] = props[key];\n    } else {\n      rest[key] = props[key];\n    }\n  }\n  return [result, rest];\n}\nvar createSplitProps = (keys) => {\n  return function split(props) {\n    return splitProps(props, keys);\n  };\n};\nfunction omit(obj, keys) {\n  return createSplitProps(keys)(obj)[1];\n}\n\n// src/store.ts\nfunction createStore(initialState, compare = Object.is) {\n  let state = { ...initialState };\n  const listeners = /* @__PURE__ */ new Set();\n  const subscribe = (listener) => {\n    listeners.add(listener);\n    return () => listeners.delete(listener);\n  };\n  const publish = () => {\n    listeners.forEach((listener) => listener());\n  };\n  const get = (key) => {\n    return state[key];\n  };\n  const set = (key, value) => {\n    if (!compare(state[key], value)) {\n      state[key] = value;\n      publish();\n    }\n  };\n  const update = (updates) => {\n    let hasChanges = false;\n    for (const key in updates) {\n      const value = updates[key];\n      if (value !== void 0 && !compare(state[key], value)) {\n        state[key] = value;\n        hasChanges = true;\n      }\n    }\n    if (hasChanges) {\n      publish();\n    }\n  };\n  const snapshot = () => ({ ...state });\n  return {\n    subscribe,\n    get,\n    set,\n    update,\n    snapshot\n  };\n}\n\n// src/timers.ts\nvar currentTime = () => performance.now();\nvar _tick;\nvar Timer = class {\n  constructor(onTick) {\n    this.onTick = onTick;\n    __publicField(this, \"frameId\", null);\n    __publicField(this, \"pausedAtMs\", null);\n    __publicField(this, \"context\");\n    __publicField(this, \"cancelFrame\", () => {\n      if (this.frameId === null) return;\n      cancelAnimationFrame(this.frameId);\n      this.frameId = null;\n    });\n    __publicField(this, \"setStartMs\", (startMs) => {\n      this.context.startMs = startMs;\n    });\n    __publicField(this, \"start\", () => {\n      if (this.frameId !== null) return;\n      const now = currentTime();\n      if (this.pausedAtMs !== null) {\n        this.context.startMs += now - this.pausedAtMs;\n        this.pausedAtMs = null;\n      } else {\n        this.context.startMs = now;\n      }\n      this.frameId = requestAnimationFrame(__privateGet(this, _tick));\n    });\n    __publicField(this, \"pause\", () => {\n      if (this.frameId === null) return;\n      this.cancelFrame();\n      this.pausedAtMs = currentTime();\n    });\n    __publicField(this, \"stop\", () => {\n      if (this.frameId === null) return;\n      this.cancelFrame();\n      this.pausedAtMs = null;\n    });\n    __privateAdd(this, _tick, (now) => {\n      this.context.now = now;\n      this.context.deltaMs = now - this.context.startMs;\n      const shouldContinue = this.onTick(this.context);\n      if (shouldContinue === false) {\n        this.stop();\n        return;\n      }\n      this.frameId = requestAnimationFrame(__privateGet(this, _tick));\n    });\n    this.context = { now: 0, startMs: currentTime(), deltaMs: 0 };\n  }\n  get elapsedMs() {\n    if (this.pausedAtMs !== null) {\n      return this.pausedAtMs - this.context.startMs;\n    }\n    return currentTime() - this.context.startMs;\n  }\n};\n_tick = new WeakMap();\nfunction setRafInterval(fn, intervalMs) {\n  const timer = new Timer(({ now, deltaMs }) => {\n    if (deltaMs >= intervalMs) {\n      const startMs = intervalMs > 0 ? now - deltaMs % intervalMs : now;\n      timer.setStartMs(startMs);\n      fn({ startMs, deltaMs });\n    }\n  });\n  timer.start();\n  return () => timer.stop();\n}\nfunction setRafTimeout(fn, delayMs) {\n  const timer = new Timer(({ deltaMs }) => {\n    if (deltaMs >= delayMs) {\n      fn();\n      return false;\n    }\n  });\n  timer.start();\n  return () => timer.stop();\n}\n\n// src/warning.ts\nfunction warn(...a) {\n  const m = a.length === 1 ? a[0] : a[1];\n  const c = a.length === 2 ? a[0] : true;\n  if (c && process.env.NODE_ENV !== \"production\") {\n    console.warn(m);\n  }\n}\nfunction invariant(...a) {\n  const m = a.length === 1 ? a[0] : a[1];\n  const c = a.length === 2 ? a[0] : true;\n  if (c && process.env.NODE_ENV !== \"production\") {\n    throw new Error(m);\n  }\n}\nfunction ensure(c, m) {\n  if (c == null) throw new Error(m());\n}\nfunction ensureProps(props, keys, scope) {\n  let missingKeys = [];\n  for (const key of keys) {\n    if (props[key] == null) missingKeys.push(key);\n  }\n  if (missingKeys.length > 0)\n    throw new Error(`[zag-js${scope ? ` > ${scope}` : \"\"}] missing required props: ${missingKeys.join(\", \")}`);\n}\n\nexport { Timer, add, addOrRemove, callAll, cast, chunk, clampPercent, clampValue, clear, compact, createSplitProps, createStore, debounce, decrementValue, diff, ensure, ensureProps, first, flatArray, fromLength, getClosestValue, getClosestValueIndex, getMaxValueAtIndex, getMinValueAtIndex, getNextStepValue, getPercentValue, getPreviousStepValue, getValuePercent, getValueRanges, getValueSetterAtIndex, getValueTransformer, has, hasProp, hash, identity, incrementValue, insertAt, invariant, isArray, isBoolean, isDev, isEmpty, isEqual, isFunction, isNaN, isNull, isNumber, isObject, isObjectLike, isPlainObject, isString, isValueAtMax, isValueAtMin, isValueWithinRange, json, last, match, mod, nan, next, nextIndex, noop, omit, partition, pick, prev, prevIndex, remove, removeAt, roundToDpr, roundToStepPrecision, roundValue, runIfFn, setRafInterval, setRafTimeout, setValueAtIndex, snapValueToStep, splitProps, throttle, toArray, toFixedNumber, toPx, tryCatch, uniq, uuid, warn, wrap };\n", "\"use client\";\n\nimport { createScope, MachineStatus, INIT_STATE } from '@zag-js/core';\nexport { mergeProps } from '@zag-js/core';\nimport { compact, ensure, isFunction, warn, toArray, isString, identity } from '@zag-js/utils';\nimport * as React from 'react';\nimport { useMemo, useRef, useState, useLayoutEffect, useEffect } from 'react';\nimport { flushSync, createPortal } from 'react-dom';\nimport { createNormalizer } from '@zag-js/types';\nimport { jsx } from 'react/jsx-runtime';\n\n// src/index.ts\nvar useSafeLayoutEffect = typeof globalThis.document !== \"undefined\" ? useLayoutEffect : useEffect;\n\n// src/bindable.ts\nfunction useBindable(props) {\n  const initial = props().value ?? props().defaultValue;\n  const eq = props().isEqual ?? Object.is;\n  const [initialValue] = useState(initial);\n  const [value, setValue] = useState(initialValue);\n  const controlled = props().value !== void 0;\n  const valueRef = useRef(value);\n  valueRef.current = controlled ? props().value : value;\n  const prevValue = useRef(valueRef.current);\n  useSafeLayoutEffect(() => {\n    prevValue.current = valueRef.current;\n  }, [value, props().value]);\n  const setFn = (value2) => {\n    const prev = prevValue.current;\n    const next = isFunction(value2) ? value2(prev) : value2;\n    if (props().debug) {\n      console.log(`[bindable > ${props().debug}] setValue`, { next, prev });\n    }\n    if (!controlled) setValue(next);\n    if (!eq(next, prev)) {\n      props().onChange?.(next, prev);\n    }\n  };\n  function get() {\n    return controlled ? props().value : value;\n  }\n  return {\n    initial: initialValue,\n    ref: valueRef,\n    get,\n    set(value2) {\n      const exec = props().sync ? flushSync : identity;\n      exec(() => setFn(value2));\n    },\n    invoke(nextValue, prevValue2) {\n      props().onChange?.(nextValue, prevValue2);\n    },\n    hash(value2) {\n      return props().hash?.(value2) ?? String(value2);\n    }\n  };\n}\nuseBindable.cleanup = (fn) => {\n  useEffect(() => fn, []);\n};\nuseBindable.ref = (defaultValue) => {\n  const value = useRef(defaultValue);\n  return {\n    get: () => value.current,\n    set: (next) => {\n      value.current = next;\n    }\n  };\n};\nfunction useRefs(refs) {\n  const ref = useRef(refs);\n  return {\n    get(key) {\n      return ref.current[key];\n    },\n    set(key, value) {\n      ref.current[key] = value;\n    }\n  };\n}\nvar useTrack = (deps, effect) => {\n  const render = useRef(false);\n  const called = useRef(false);\n  useEffect(() => {\n    const mounted = render.current;\n    const run = mounted && called.current;\n    if (run) return effect();\n    called.current = true;\n  }, [...(deps ?? []).map((d) => typeof d === \"function\" ? d() : d)]);\n  useEffect(() => {\n    render.current = true;\n    return () => {\n      render.current = false;\n    };\n  }, []);\n};\n\n// src/machine.ts\nfunction useMachine(machine, userProps = {}) {\n  const scope = useMemo(() => {\n    const { id, ids, getRootNode } = userProps;\n    return createScope({ id, ids, getRootNode });\n  }, [userProps]);\n  const debug = (...args) => {\n    if (machine.debug) console.log(...args);\n  };\n  const props = machine.props?.({ props: compact(userProps), scope }) ?? userProps;\n  const prop = useProp(props);\n  const context = machine.context?.({\n    prop,\n    bindable: useBindable,\n    scope,\n    flush,\n    getContext() {\n      return ctx;\n    },\n    getComputed() {\n      return computed;\n    },\n    getRefs() {\n      return refs;\n    },\n    getEvent() {\n      return getEvent();\n    }\n  });\n  const contextRef = useLiveRef(context);\n  const ctx = {\n    get(key) {\n      return contextRef.current?.[key].ref.current;\n    },\n    set(key, value) {\n      contextRef.current?.[key].set(value);\n    },\n    initial(key) {\n      return contextRef.current?.[key].initial;\n    },\n    hash(key) {\n      const current = contextRef.current?.[key].get();\n      return contextRef.current?.[key].hash(current);\n    }\n  };\n  const effects = useRef(/* @__PURE__ */ new Map());\n  const transitionRef = useRef(null);\n  const previousEventRef = useRef(null);\n  const eventRef = useRef({ type: \"\" });\n  const getEvent = () => ({\n    ...eventRef.current,\n    current() {\n      return eventRef.current;\n    },\n    previous() {\n      return previousEventRef.current;\n    }\n  });\n  const getState = () => ({\n    ...state,\n    matches(...values) {\n      return values.includes(state.ref.current);\n    },\n    hasTag(tag) {\n      return !!machine.states[state.ref.current]?.tags?.includes(tag);\n    }\n  });\n  const refs = useRefs(machine.refs?.({ prop, context: ctx }) ?? {});\n  const getParams = () => ({\n    state: getState(),\n    context: ctx,\n    event: getEvent(),\n    prop,\n    send,\n    action,\n    guard,\n    track: useTrack,\n    refs,\n    computed,\n    flush,\n    scope,\n    choose\n  });\n  const action = (keys) => {\n    const strs = isFunction(keys) ? keys(getParams()) : keys;\n    if (!strs) return;\n    const fns = strs.map((s) => {\n      const fn = machine.implementations?.actions?.[s];\n      if (!fn) warn(`[zag-js] No implementation found for action \"${JSON.stringify(s)}\"`);\n      return fn;\n    });\n    for (const fn of fns) {\n      fn?.(getParams());\n    }\n  };\n  const guard = (str) => {\n    if (isFunction(str)) return str(getParams());\n    return machine.implementations?.guards?.[str](getParams());\n  };\n  const effect = (keys) => {\n    const strs = isFunction(keys) ? keys(getParams()) : keys;\n    if (!strs) return;\n    const fns = strs.map((s) => {\n      const fn = machine.implementations?.effects?.[s];\n      if (!fn) warn(`[zag-js] No implementation found for effect \"${JSON.stringify(s)}\"`);\n      return fn;\n    });\n    const cleanups = [];\n    for (const fn of fns) {\n      const cleanup = fn?.(getParams());\n      if (cleanup) cleanups.push(cleanup);\n    }\n    return () => cleanups.forEach((fn) => fn?.());\n  };\n  const choose = (transitions) => {\n    return toArray(transitions).find((t) => {\n      let result = !t.guard;\n      if (isString(t.guard)) result = !!guard(t.guard);\n      else if (isFunction(t.guard)) result = t.guard(getParams());\n      return result;\n    });\n  };\n  const computed = (key) => {\n    ensure(machine.computed, () => `[zag-js] No computed object found on machine`);\n    const fn = machine.computed[key];\n    return fn({\n      context: ctx,\n      event: getEvent(),\n      prop,\n      refs,\n      scope,\n      computed\n    });\n  };\n  const state = useBindable(() => ({\n    defaultValue: machine.initialState({ prop }),\n    onChange(nextState, prevState) {\n      if (prevState) {\n        const exitEffects = effects.current.get(prevState);\n        exitEffects?.();\n        effects.current.delete(prevState);\n      }\n      if (prevState) {\n        action(machine.states[prevState]?.exit);\n      }\n      action(transitionRef.current?.actions);\n      const cleanup = effect(machine.states[nextState]?.effects);\n      if (cleanup) effects.current.set(nextState, cleanup);\n      if (prevState === INIT_STATE) {\n        action(machine.entry);\n        const cleanup2 = effect(machine.effects);\n        if (cleanup2) effects.current.set(INIT_STATE, cleanup2);\n      }\n      action(machine.states[nextState]?.entry);\n    }\n  }));\n  const hydratedStateRef = useRef(void 0);\n  const statusRef = useRef(MachineStatus.NotStarted);\n  useSafeLayoutEffect(() => {\n    queueMicrotask(() => {\n      const started = statusRef.current === MachineStatus.Started;\n      statusRef.current = MachineStatus.Started;\n      debug(started ? \"rehydrating...\" : \"initializing...\");\n      const initialState = hydratedStateRef.current ?? state.initial;\n      state.invoke(initialState, started ? state.get() : INIT_STATE);\n    });\n    const fns = effects.current;\n    const currentState = state.ref.current;\n    return () => {\n      debug(\"unmounting...\");\n      hydratedStateRef.current = currentState;\n      statusRef.current = MachineStatus.Stopped;\n      fns.forEach((fn) => fn?.());\n      effects.current = /* @__PURE__ */ new Map();\n      transitionRef.current = null;\n      queueMicrotask(() => {\n        action(machine.exit);\n      });\n    };\n  }, []);\n  const getCurrentState = () => {\n    if (\"ref\" in state) return state.ref.current;\n    return state.get();\n  };\n  const send = (event) => {\n    queueMicrotask(() => {\n      if (statusRef.current !== MachineStatus.Started) return;\n      previousEventRef.current = eventRef.current;\n      eventRef.current = event;\n      let currentState = getCurrentState();\n      const transitions = (\n        // @ts-ignore\n        machine.states[currentState].on?.[event.type] ?? // @ts-ignore\n        machine.on?.[event.type]\n      );\n      const transition = choose(transitions);\n      if (!transition) return;\n      transitionRef.current = transition;\n      const target = transition.target ?? currentState;\n      debug(\"transition\", event.type, transition.target || currentState, `(${transition.actions})`);\n      const changed = target !== currentState;\n      if (changed) {\n        flushSync(() => state.set(target));\n      } else if (transition.reenter && !changed) {\n        state.invoke(currentState, currentState);\n      } else {\n        action(transition.actions ?? []);\n      }\n    });\n  };\n  machine.watch?.(getParams());\n  return {\n    state: getState(),\n    send,\n    context: ctx,\n    prop,\n    scope,\n    refs,\n    computed,\n    event: getEvent(),\n    getStatus: () => statusRef.current\n  };\n}\nfunction useLiveRef(value) {\n  const ref = useRef(value);\n  ref.current = value;\n  return ref;\n}\nfunction useProp(value) {\n  const ref = useLiveRef(value);\n  return function get(key) {\n    return ref.current[key];\n  };\n}\nfunction flush(fn) {\n  queueMicrotask(() => {\n    flushSync(() => fn());\n  });\n}\nvar normalizeProps = createNormalizer((v) => v);\nvar Portal = (props) => {\n  const { children, container, disabled, getRootNode } = props;\n  const isServer = typeof window === \"undefined\";\n  if (isServer || disabled) return /* @__PURE__ */ jsx(React.Fragment, { children });\n  const doc = getRootNode?.().ownerDocument ?? document;\n  const mountNode = container?.current ?? doc.body;\n  return /* @__PURE__ */ jsx(React.Fragment, { children: React.Children.map(children, (child) => createPortal(child, mountNode)) });\n};\n\nexport { Portal, normalizeProps, useMachine };\n", "'use client';\nimport { useCarouselContext } from './use-carousel-context.js';\n\nconst CarouselContext = (props) => props.children(useCarouselContext());\n\nexport { CarouselContext };\n", "'use client';\nimport { jsx } from 'react/jsx-runtime';\nimport { mergeProps } from '@zag-js/react';\nimport { forwardRef } from 'react';\nimport { ark } from '../factory.js';\nimport { useCarouselContext } from './use-carousel-context.js';\n\nconst CarouselControl = forwardRef((props, ref) => {\n  const carousel = useCarouselContext();\n  const mergedProps = mergeProps(carousel.getControlProps(), props);\n  return /* @__PURE__ */ jsx(ark.div, { ...mergedProps, ...props, ref });\n});\nCarouselControl.displayName = \"CarouselControl\";\n\nexport { CarouselControl };\n", "'use client';\nimport { jsx } from 'react/jsx-runtime';\nimport { mergeProps } from '@zag-js/react';\nimport { forwardRef } from 'react';\nimport { createSplitProps } from '../../utils/create-split-props.js';\nimport { ark } from '../factory.js';\nimport { useCarouselContext } from './use-carousel-context.js';\n\nconst splitIndicatorProps = createSplitProps();\nconst CarouselIndicator = forwardRef((props, ref) => {\n  const [indicatorProps, localProps] = splitIndicatorProps(props, [\"readOnly\", \"index\"]);\n  const carousel = useCarouselContext();\n  const mergedProps = mergeProps(carousel.getIndicatorProps(indicatorProps), localProps);\n  return /* @__PURE__ */ jsx(ark.button, { ...mergedProps, ref });\n});\nCarouselIndicator.displayName = \"CarouselIndicator\";\n\nexport { CarouselIndicator };\n", "'use client';\nconst createSplitProps = () => (props, keys) => keys.reduce(\n  (previousValue, currentValue) => {\n    const [target, source] = previousValue;\n    const key = currentValue;\n    if (source[key] !== void 0) {\n      target[key] = source[key];\n    }\n    delete source[key];\n    return [target, source];\n  },\n  [{}, { ...props }]\n);\n\nexport { createSplitProps };\n", "'use client';\nimport { jsx } from 'react/jsx-runtime';\nimport { mergeProps } from '@zag-js/react';\nimport { forwardRef } from 'react';\nimport { ark } from '../factory.js';\nimport { useCarouselContext } from './use-carousel-context.js';\n\nconst CarouselIndicatorGroup = forwardRef((props, ref) => {\n  const carousel = useCarouselContext();\n  const mergedProps = mergeProps(carousel.getIndicatorGroupProps(), props);\n  return /* @__PURE__ */ jsx(ark.div, { ...mergedProps, ref });\n});\nCarouselIndicatorGroup.displayName = \"CarouselIndicatorGroup\";\n\nexport { CarouselIndicatorGroup };\n", "'use client';\nimport { jsx } from 'react/jsx-runtime';\nimport { mergeProps } from '@zag-js/react';\nimport { forwardRef } from 'react';\nimport { createSplitProps } from '../../utils/create-split-props.js';\nimport { ark } from '../factory.js';\nimport { useCarouselContext } from './use-carousel-context.js';\n\nconst splitItemProps = createSplitProps();\nconst CarouselItem = forwardRef((props, ref) => {\n  const [itemProps, localProps] = splitItemProps(props, [\"index\", \"snapAlign\"]);\n  const carousel = useCarouselContext();\n  const mergedProps = mergeProps(carousel.getItemProps(itemProps), localProps);\n  return /* @__PURE__ */ jsx(ark.div, { ...mergedProps, ref });\n});\nCarouselItem.displayName = \"CarouselItem\";\n\nexport { CarouselItem };\n", "'use client';\nimport { jsx } from 'react/jsx-runtime';\nimport { mergeProps } from '@zag-js/react';\nimport { forwardRef } from 'react';\nimport { ark } from '../factory.js';\nimport { useCarouselContext } from './use-carousel-context.js';\n\nconst CarouselItemGroup = forwardRef((props, ref) => {\n  const carousel = useCarouselContext();\n  const mergedProps = mergeProps(carousel.getItemGroupProps(), props);\n  return /* @__PURE__ */ jsx(ark.div, { ...mergedProps, ref });\n});\nCarouselItemGroup.displayName = \"CarouselItemGroup\";\n\nexport { CarouselItemGroup };\n", "'use client';\nimport { jsx } from 'react/jsx-runtime';\nimport { mergeProps } from '@zag-js/react';\nimport { forwardRef } from 'react';\nimport { ark } from '../factory.js';\nimport { useCarouselContext } from './use-carousel-context.js';\n\nconst CarouselNextTrigger = forwardRef((props, ref) => {\n  const carousel = useCarouselContext();\n  const mergedProps = mergeProps(carousel.getNextTriggerProps(), props);\n  return /* @__PURE__ */ jsx(ark.button, { ...mergedProps, ref });\n});\nCarouselNextTrigger.displayName = \"CarouselNextTrigger\";\n\nexport { CarouselNextTrigger };\n", "'use client';\nimport { jsx } from 'react/jsx-runtime';\nimport { mergeProps } from '@zag-js/react';\nimport { forwardRef } from 'react';\nimport { ark } from '../factory.js';\nimport { useCarouselContext } from './use-carousel-context.js';\n\nconst CarouselPrevTrigger = forwardRef((props, ref) => {\n  const carousel = useCarouselContext();\n  const mergedProps = mergeProps(carousel.getPrevTriggerProps(), props);\n  return /* @__PURE__ */ jsx(ark.button, { ...mergedProps, ref });\n});\nCarouselPrevTrigger.displayName = \"CarouselPrevTrigger\";\n\nexport { CarouselPrevTrigger };\n", "'use client';\nimport { jsx } from 'react/jsx-runtime';\nimport { mergeProps } from '@zag-js/react';\nimport { forwardRef } from 'react';\nimport { createSplitProps } from '../../utils/create-split-props.js';\nimport { ark } from '../factory.js';\nimport { useCarousel } from './use-carousel.js';\nimport { CarouselProvider } from './use-carousel-context.js';\n\nconst splitRootProps = createSplitProps();\nconst CarouselRoot = forwardRef((props, ref) => {\n  const [useCarouselProps, localProps] = splitRootProps(props, [\n    \"allowMouseDrag\",\n    \"autoplay\",\n    \"autoSize\",\n    \"defaultPage\",\n    \"id\",\n    \"ids\",\n    \"inViewThreshold\",\n    \"loop\",\n    \"onAutoplayStatusChange\",\n    \"onDragStatusChange\",\n    \"onPageChange\",\n    \"orientation\",\n    \"padding\",\n    \"page\",\n    \"slideCount\",\n    \"slidesPerMove\",\n    \"slidesPerPage\",\n    \"snapType\",\n    \"spacing\",\n    \"translations\"\n  ]);\n  const carousel = useCarousel(useCarouselProps);\n  const mergedProps = mergeProps(carousel.getRootProps(), localProps);\n  return /* @__PURE__ */ jsx(CarouselProvider, { value: carousel, children: /* @__PURE__ */ jsx(ark.div, { ...mergedProps, ref }) });\n});\nCarouselRoot.displayName = \"CarouselRoot\";\n\nexport { CarouselRoot };\n", "'use client';\nimport * as carousel from '@zag-js/carousel';\nimport { useMachine, normalizeProps } from '@zag-js/react';\nimport { useId } from 'react';\nimport { useEnvironmentContext } from '../../providers/environment/use-environment-context.js';\nimport { useLocaleContext } from '../../providers/locale/use-locale-context.js';\n\nconst useCarousel = (props) => {\n  const id = useId();\n  const { getRootNode } = useEnvironmentContext();\n  const { dir } = useLocaleContext();\n  const machineProps = {\n    id,\n    dir,\n    getRootNode,\n    ...props\n  };\n  const service = useMachine(carousel.machine, machineProps);\n  return carousel.connect(service, normalizeProps);\n};\n\nexport { useCarousel };\n", "'use client';\nimport { createContext } from '../../utils/create-context.js';\n\nconst [EnvironmentContextProvider, useEnvironmentContext] = createContext({\n  name: \"EnvironmentContext\",\n  hookName: \"useEnvironmentContext\",\n  providerName: \"<EnvironmentProvider />\",\n  strict: false,\n  defaultValue: {\n    getRootNode: () => document,\n    getDocument: () => document,\n    getWindow: () => window\n  }\n});\n\nexport { EnvironmentContextProvider, useEnvironmentContext };\n", "'use client';\nimport { createContext } from '../../utils/create-context.js';\n\nconst [LocaleContextProvider, useLocaleContext] = createContext({\n  name: \"LocaleContext\",\n  hookName: \"useLocaleContext\",\n  providerName: \"<LocaleProvider />\",\n  strict: false,\n  defaultValue: { dir: \"ltr\", locale: \"en-US\" }\n});\n\nexport { LocaleContextProvider, useLocaleContext };\n", "'use client';\nimport { jsx } from 'react/jsx-runtime';\nimport { mergeProps } from '@zag-js/react';\nimport { forwardRef } from 'react';\nimport { createSplitProps } from '../../utils/create-split-props.js';\nimport { ark } from '../factory.js';\nimport { CarouselProvider } from './use-carousel-context.js';\n\nconst splitRootProviderProps = createSplitProps();\nconst CarouselRootProvider = forwardRef((props, ref) => {\n  const [{ value: carousel }, localProps] = splitRootProviderProps(props, [\"value\"]);\n  const mergedProps = mergeProps(carousel.getRootProps(), localProps);\n  return /* @__PURE__ */ jsx(CarouselProvider, { value: carousel, children: /* @__PURE__ */ jsx(ark.div, { ...mergedProps, ref }) });\n});\nCarouselRootProvider.displayName = \"CarouselRootProvider\";\n\nexport { CarouselRootProvider };\n", "export { CarouselAutoplayIndicator as AutoplayIndicator } from './carousel-autoplay-indicator.js';\nexport { CarouselProgressText as ProgressText } from './carousel-progress-text.js';\nexport { CarouselAutoplayTrigger as AutoplayTrigger } from './carousel-autoplay-trigger.js';\nexport { CarouselContext as Context } from './carousel-context.js';\nexport { CarouselControl as Control } from './carousel-control.js';\nexport { CarouselIndicator as Indicator } from './carousel-indicator.js';\nexport { CarouselIndicatorGroup as IndicatorGroup } from './carousel-indicator-group.js';\nexport { CarouselItem as Item } from './carousel-item.js';\nexport { CarouselItemGroup as ItemGroup } from './carousel-item-group.js';\nexport { CarouselNextTrigger as NextTrigger } from './carousel-next-trigger.js';\nexport { CarouselPrevTrigger as PrevTrigger } from './carousel-prev-trigger.js';\nexport { CarouselRoot as Root } from './carousel-root.js';\nexport { CarouselRootProvider as RootProvider } from './carousel-root-provider.js';\n"],
  "mappings": "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",
  "names": ["import_react", "getComputedStyle", "match", "props", "props", "props", "parts", "isObject", "fnToString", "objectCtorString", "callAll", "floor", "abs", "round", "min", "max", "pow", "sign", "min", "max", "props", "_tick", "_tick", "props", "getComputedStyle", "uniq", "uniq", "min", "max", "props", "state", "keyMap", "isObject", "callAll", "flush", "splitProps", "import_react", "createContext$1", "parts", "props", "import_jsx_runtime", "import_react", "parts", "props", "import_jsx_runtime", "isObjectLike", "isString", "isFunction", "hasProp", "fnToString", "objectCtorString", "isObjectLike", "floor", "abs", "round", "min", "max", "pow", "sign", "_tick", "_tick", "import_react", "import_jsx_runtime", "props", "isFunction", "machine", "state", "isString", "import_react", "props", "props", "import_jsx_runtime", "import_react", "props", "import_jsx_runtime", "import_react", "createSplitProps", "props", "splitIndicatorProps", "createSplitProps", "props", "indicatorProps", "import_jsx_runtime", "import_react", "props", "import_jsx_runtime", "import_react", "splitItemProps", "createSplitProps", "props", "itemProps", "import_jsx_runtime", "import_react", "props", "import_jsx_runtime", "import_react", "props", "import_jsx_runtime", "import_react", "props", "import_jsx_runtime", "import_react", "import_react", "props", "createSplitProps", "props", "import_jsx_runtime", "import_react", "createSplitProps", "props"]
}
