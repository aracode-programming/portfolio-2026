import {
  require_jsx_runtime
} from "./chunk-5EPD7TB4.js";
import {
  require_react_dom
} from "./chunk-E77T7Q56.js";
import {
  require_react
} from "./chunk-TMM3WI36.js";
import {
  __export,
  __toESM
} from "./chunk-V4OQ3NZ2.js";

// node_modules/@ark-ui/react/dist/components/carousel/carousel-autoplay-indicator.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var import_react3 = __toESM(require_react(), 1);

// node_modules/@zag-js/core/node_modules/@zag-js/utils/dist/index.mjs
var isString = (v) => typeof v === "string";
var fnToString = Function.prototype.toString;
var objectCtorString = fnToString.call(Object);
var callAll = (...fns) => (...a) => {
  fns.forEach(function(fn) {
    fn?.(...a);
  });
};
var { floor, abs, round, min, max, pow, sign } = Math;
var _tick;
_tick = /* @__PURE__ */ new WeakMap();

// node_modules/@zag-js/dom-query/dist/index.mjs
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var wrap = (v, idx) => {
  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);
};
var isObject = (v) => typeof v === "object" && v !== null;
var dataAttr = (guard) => guard ? "" : void 0;
var ariaAttr = (guard) => guard ? "true" : void 0;
var ELEMENT_NODE = 1;
var DOCUMENT_NODE = 9;
var DOCUMENT_FRAGMENT_NODE = 11;
var isHTMLElement = (el) => isObject(el) && el.nodeType === ELEMENT_NODE && typeof el.nodeName === "string";
var isDocument = (el) => isObject(el) && el.nodeType === DOCUMENT_NODE;
var isWindow = (el) => isObject(el) && el === el.window;
var isNode = (el) => isObject(el) && el.nodeType !== void 0;
var isShadowRoot = (el) => isNode(el) && el.nodeType === DOCUMENT_FRAGMENT_NODE && "host" in el;
var isElementVisible = (el) => {
  if (!isHTMLElement(el)) return false;
  return el.offsetWidth > 0 || el.offsetHeight > 0 || el.getClientRects().length > 0;
};
function isActiveElement(element) {
  if (!element) return false;
  const rootNode = element.getRootNode();
  return getActiveElement(rootNode) === element;
}
function contains(parent, child) {
  if (!parent || !child) return false;
  if (!isHTMLElement(parent) || !isHTMLElement(child)) return false;
  const rootNode = child.getRootNode?.();
  if (parent === child) return true;
  if (parent.contains(child)) return true;
  if (rootNode && isShadowRoot(rootNode)) {
    let next = child;
    while (next) {
      if (parent === next) return true;
      next = next.parentNode || next.host;
    }
  }
  return false;
}
function getDocument(el) {
  if (isDocument(el)) return el;
  if (isWindow(el)) return el.document;
  return el?.ownerDocument ?? document;
}
function getWindow(el) {
  if (isShadowRoot(el)) return getWindow(el.host);
  if (isDocument(el)) return el.defaultView ?? window;
  if (isHTMLElement(el)) return el.ownerDocument?.defaultView ?? window;
  return window;
}
function getActiveElement(rootNode) {
  let activeElement = rootNode.activeElement;
  while (activeElement?.shadowRoot) {
    const el = activeElement.shadowRoot.activeElement;
    if (!el || el === activeElement) break;
    else activeElement = el;
  }
  return activeElement;
}
var styleCache = /* @__PURE__ */ new WeakMap();
function getComputedStyle2(el) {
  if (!styleCache.has(el)) {
    styleCache.set(el, getWindow(el).getComputedStyle(el));
  }
  return styleCache.get(el);
}
var isDom = () => typeof document !== "undefined";
function getPlatform() {
  const agent = navigator.userAgentData;
  return agent?.platform ?? navigator.platform;
}
var pt = (v) => isDom() && v.test(getPlatform());
var isIPhone = () => pt(/^iPhone/i);
var isIPad = () => pt(/^iPad/i) || isMac() && navigator.maxTouchPoints > 1;
var isIos = () => isIPhone() || isIPad();
var isMac = () => pt(/^Mac/i);
function getComposedPath(event) {
  return event.composedPath?.() ?? event.nativeEvent?.composedPath?.();
}
function getEventTarget(event) {
  const composedPath = getComposedPath(event);
  return composedPath?.[0] ?? event.target;
}
var isLeftClick = (e) => e.button === 0;
var isTouchEvent = (event) => "touches" in event && event.touches.length > 0;
var keyMap = {
  Up: "ArrowUp",
  Down: "ArrowDown",
  Esc: "Escape",
  " ": "Space",
  ",": "Comma",
  Left: "ArrowLeft",
  Right: "ArrowRight"
};
var rtlKeyMap = {
  ArrowLeft: "ArrowRight",
  ArrowRight: "ArrowLeft"
};
function getEventKey(event, options = {}) {
  const { dir = "ltr", orientation = "horizontal" } = options;
  let key = event.key;
  key = keyMap[key] ?? key;
  const isRtl = dir === "rtl" && orientation === "horizontal";
  if (isRtl && key in rtlKeyMap) key = rtlKeyMap[key];
  return key;
}
function getEventPoint(event, type = "client") {
  const point = isTouchEvent(event) ? event.touches[0] || event.changedTouches[0] : event;
  return { x: point[`${type}X`], y: point[`${type}Y`] };
}
var addDomEvent = (target, eventName, handler, options) => {
  const node = typeof target === "function" ? target() : target;
  node?.addEventListener(eventName, handler, options);
  return () => {
    node?.removeEventListener(eventName, handler, options);
  };
};
var isFrame = (el) => isHTMLElement(el) && el.tagName === "IFRAME";
function parseTabIndex(el) {
  const attr = el.getAttribute("tabindex");
  if (!attr) return NaN;
  return parseInt(attr, 10);
}
var hasNegativeTabIndex = (el) => parseTabIndex(el) < 0;
function getShadowRootForNode(element, getShadowRoot) {
  if (!getShadowRoot) return null;
  if (getShadowRoot === true) {
    return element.shadowRoot || null;
  }
  const result = getShadowRoot(element);
  return (result === true ? element.shadowRoot : result) || null;
}
function collectElementsWithShadowDOM(elements, getShadowRoot, filterFn) {
  const allElements = [...elements];
  const toProcess = [...elements];
  const processed = /* @__PURE__ */ new Set();
  const positionMap = /* @__PURE__ */ new Map();
  elements.forEach((el, i) => positionMap.set(el, i));
  let processIndex = 0;
  while (processIndex < toProcess.length) {
    const element = toProcess[processIndex++];
    if (!element || processed.has(element)) continue;
    processed.add(element);
    const shadowRoot = getShadowRootForNode(element, getShadowRoot);
    if (shadowRoot) {
      const shadowElements = Array.from(shadowRoot.querySelectorAll(focusableSelector)).filter(filterFn);
      const hostIndex = positionMap.get(element);
      if (hostIndex !== void 0) {
        const insertPosition = hostIndex + 1;
        allElements.splice(insertPosition, 0, ...shadowElements);
        shadowElements.forEach((el, i) => {
          positionMap.set(el, insertPosition + i);
        });
        for (let i = insertPosition + shadowElements.length; i < allElements.length; i++) {
          positionMap.set(allElements[i], i);
        }
      } else {
        const insertPosition = allElements.length;
        allElements.push(...shadowElements);
        shadowElements.forEach((el, i) => {
          positionMap.set(el, insertPosition + i);
        });
      }
      toProcess.push(...shadowElements);
    }
  }
  return allElements;
}
var focusableSelector = "input:not([type='hidden']):not([disabled]), select:not([disabled]), textarea:not([disabled]), a[href], button:not([disabled]), [tabindex], iframe, object, embed, area[href], audio[controls], video[controls], [contenteditable]:not([contenteditable='false']), details > summary:first-of-type";
function isFocusable(element) {
  if (!isHTMLElement(element) || element.closest("[inert]")) return false;
  return element.matches(focusableSelector) && isElementVisible(element);
}
function getTabbables(container, options = {}) {
  if (!container) return [];
  const { includeContainer, getShadowRoot } = options;
  const elements = Array.from(container.querySelectorAll(focusableSelector));
  if (includeContainer && isTabbable(container)) {
    elements.unshift(container);
  }
  const tabbableElements = [];
  for (const element of elements) {
    if (!isTabbable(element)) continue;
    if (isFrame(element) && element.contentDocument) {
      const frameBody = element.contentDocument.body;
      tabbableElements.push(...getTabbables(frameBody, { getShadowRoot }));
      continue;
    }
    tabbableElements.push(element);
  }
  if (getShadowRoot) {
    const allElements = collectElementsWithShadowDOM(tabbableElements, getShadowRoot, isTabbable);
    if (!allElements.length && includeContainer) {
      return elements;
    }
    return allElements;
  }
  if (!tabbableElements.length && includeContainer) {
    return elements;
  }
  return tabbableElements;
}
function isTabbable(el) {
  if (isHTMLElement(el) && el.tabIndex > 0) return true;
  return isFocusable(el) && !hasNegativeTabIndex(el);
}
var AnimationFrame = class _AnimationFrame {
  constructor() {
    __publicField(this, "id", null);
    __publicField(this, "fn_cleanup");
    __publicField(this, "cleanup", () => {
      this.cancel();
    });
  }
  static create() {
    return new _AnimationFrame();
  }
  request(fn) {
    this.cancel();
    this.id = globalThis.requestAnimationFrame(() => {
      this.id = null;
      this.fn_cleanup = fn?.();
    });
  }
  cancel() {
    if (this.id !== null) {
      globalThis.cancelAnimationFrame(this.id);
      this.id = null;
    }
    this.fn_cleanup?.();
    this.fn_cleanup = void 0;
  }
  isActive() {
    return this.id !== null;
  }
};
function raf(fn) {
  const frame = AnimationFrame.create();
  frame.request(fn);
  return frame.cleanup;
}
function nextTick(fn) {
  const set = /* @__PURE__ */ new Set();
  function raf2(fn2) {
    const id = globalThis.requestAnimationFrame(fn2);
    set.add(() => globalThis.cancelAnimationFrame(id));
  }
  raf2(() => raf2(fn));
  return function cleanup() {
    set.forEach((fn2) => fn2());
  };
}
var state = "default";
var userSelect = "";
var elementMap = /* @__PURE__ */ new WeakMap();
function disableTextSelectionImpl(options = {}) {
  const { target, doc } = options;
  const docNode = doc ?? document;
  const rootEl = docNode.documentElement;
  if (isIos()) {
    if (state === "default") {
      userSelect = rootEl.style.webkitUserSelect;
      rootEl.style.webkitUserSelect = "none";
    }
    state = "disabled";
  } else if (target) {
    elementMap.set(target, target.style.userSelect);
    target.style.userSelect = "none";
  }
  return () => restoreTextSelection({ target, doc: docNode });
}
function restoreTextSelection(options = {}) {
  const { target, doc } = options;
  const docNode = doc ?? document;
  const rootEl = docNode.documentElement;
  if (isIos()) {
    if (state !== "disabled") return;
    state = "restoring";
    setTimeout(() => {
      nextTick(() => {
        if (state === "restoring") {
          if (rootEl.style.webkitUserSelect === "none") {
            rootEl.style.webkitUserSelect = userSelect || "";
          }
          userSelect = "";
          state = "default";
        }
      });
    }, 300);
  } else {
    if (target && elementMap.has(target)) {
      const prevUserSelect = elementMap.get(target);
      if (target.style.userSelect === "none") {
        target.style.userSelect = prevUserSelect ?? "";
      }
      if (target.getAttribute("style") === "") {
        target.removeAttribute("style");
      }
      elementMap.delete(target);
    }
  }
}
function disableTextSelection(options = {}) {
  const { defer, target, ...restOptions } = options;
  const func = defer ? raf : (v) => v();
  const cleanups = [];
  cleanups.push(
    func(() => {
      const node = typeof target === "function" ? target() : target;
      cleanups.push(disableTextSelectionImpl({ ...restOptions, target: node }));
    })
  );
  return () => {
    cleanups.forEach((fn) => fn?.());
  };
}
function trackPointerMove(doc, handlers) {
  const { onPointerMove, onPointerUp } = handlers;
  const handleMove = (event) => {
    const point = getEventPoint(event);
    const distance = Math.sqrt(point.x ** 2 + point.y ** 2);
    const moveBuffer = event.pointerType === "touch" ? 10 : 5;
    if (distance < moveBuffer) return;
    if (event.pointerType === "mouse" && event.buttons === 0) {
      handleUp(event);
      return;
    }
    onPointerMove({ point, event });
  };
  const handleUp = (event) => {
    const point = getEventPoint(event);
    onPointerUp({ point, event });
  };
  const cleanups = [
    addDomEvent(doc, "pointermove", handleMove, false),
    addDomEvent(doc, "pointerup", handleUp, false),
    addDomEvent(doc, "pointercancel", handleUp, false),
    addDomEvent(doc, "contextmenu", handleUp, false),
    disableTextSelection({ doc })
  ];
  return () => {
    cleanups.forEach((cleanup) => cleanup());
  };
}
function queryAll(root, selector) {
  return Array.from(root?.querySelectorAll(selector) ?? []);
}
var defaultItemToId = (v) => v.id;
function itemById(v, id, itemToId = defaultItemToId) {
  return v.find((item) => itemToId(item) === id);
}
function indexOfId(v, id, itemToId = defaultItemToId) {
  const item = itemById(v, id, itemToId);
  return item ? v.indexOf(item) : -1;
}
function createSharedResizeObserver(options) {
  const listeners = /* @__PURE__ */ new WeakMap();
  let observer;
  const entries = /* @__PURE__ */ new WeakMap();
  const getObserver = (win) => {
    if (observer) return observer;
    observer = new win.ResizeObserver((observedEntries) => {
      for (const entry of observedEntries) {
        entries.set(entry.target, entry);
        const elementListeners = listeners.get(entry.target);
        if (elementListeners) {
          for (const listener of elementListeners) {
            listener(entry);
          }
        }
      }
    });
    return observer;
  };
  const observe = (element, listener) => {
    let elementListeners = listeners.get(element) || /* @__PURE__ */ new Set();
    elementListeners.add(listener);
    listeners.set(element, elementListeners);
    const win = getWindow(element);
    getObserver(win).observe(element, options);
    return () => {
      const elementListeners2 = listeners.get(element);
      if (!elementListeners2) return;
      elementListeners2.delete(listener);
      if (elementListeners2.size === 0) {
        listeners.delete(element);
        getObserver(win).unobserve(element);
      }
    };
  };
  const unobserve = (element) => {
    listeners.delete(element);
    observer?.unobserve(element);
  };
  return {
    observe,
    unobserve
  };
}
var resizeObserverContentBox = createSharedResizeObserver({
  box: "content-box"
});
var resizeObserverBorderBox = createSharedResizeObserver({
  box: "border-box"
});
var resizeObserverDevicePixelContentBox = createSharedResizeObserver({
  box: "device-pixel-content-box"
});
var sanitize = (str) => str.split("").map((char) => {
  const code = char.charCodeAt(0);
  if (code > 0 && code < 128) return char;
  if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace("/", "\\");
  return "";
}).join("").trim();
var getValueText = (el) => {
  return sanitize(el.dataset?.valuetext ?? el.textContent ?? "");
};
var match = (valueText, query2) => {
  return valueText.trim().toLowerCase().startsWith(query2.toLowerCase());
};
function getByText(v, text, currentId, itemToId = defaultItemToId) {
  const index = currentId ? indexOfId(v, currentId, itemToId) : -1;
  let items = currentId ? wrap(v, index) : v;
  const isSingleKey = text.length === 1;
  if (isSingleKey) {
    items = items.filter((item) => itemToId(item) !== currentId);
  }
  return items.find((item) => match(getValueText(item), text));
}
function getByTypeaheadImpl(baseItems, options) {
  const { state: state2, activeId, key, timeout = 350, itemToId } = options;
  const search = state2.keysSoFar + key;
  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);
  const query2 = isRepeated ? search[0] : search;
  let items = baseItems.slice();
  const next = getByText(items, query2, activeId, itemToId);
  function cleanup() {
    clearTimeout(state2.timer);
    state2.timer = -1;
  }
  function update(value) {
    state2.keysSoFar = value;
    cleanup();
    if (value !== "") {
      state2.timer = +setTimeout(() => {
        update("");
        cleanup();
      }, timeout);
    }
  }
  update(search);
  return next;
}
var getByTypeahead = Object.assign(getByTypeaheadImpl, {
  defaultOptions: { keysSoFar: "", timer: -1 },
  isValidEvent: isValidTypeaheadEvent
});
function isValidTypeaheadEvent(event) {
  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;
}

// node_modules/@zag-js/core/dist/index.mjs
var clsx = (...args) => args.map((str) => str?.trim?.()).filter(Boolean).join(" ");
var CSS_REGEX = /((?:--)?(?:\w+-?)+)\s*:\s*([^;]*)/g;
var serialize = (style) => {
  const res = {};
  let match2;
  while (match2 = CSS_REGEX.exec(style)) {
    res[match2[1]] = match2[2];
  }
  return res;
};
var css = (a, b) => {
  if (isString(a)) {
    if (isString(b)) return `${a};${b}`;
    a = serialize(a);
  } else if (isString(b)) {
    b = serialize(b);
  }
  return Object.assign({}, a ?? {}, b ?? {});
};
function mergeProps(...args) {
  let result = {};
  for (let props2 of args) {
    if (!props2) continue;
    for (let key in result) {
      if (key.startsWith("on") && typeof result[key] === "function" && typeof props2[key] === "function") {
        result[key] = callAll(props2[key], result[key]);
        continue;
      }
      if (key === "className" || key === "class") {
        result[key] = clsx(result[key], props2[key]);
        continue;
      }
      if (key === "style") {
        result[key] = css(result[key], props2[key]);
        continue;
      }
      result[key] = props2[key] !== void 0 ? props2[key] : result[key];
    }
    for (let key in props2) {
      if (result[key] === void 0) {
        result[key] = props2[key];
      }
    }
    const symbols = Object.getOwnPropertySymbols(props2);
    for (let symbol of symbols) {
      result[symbol] = props2[symbol];
    }
  }
  return result;
}
function createMachine(config) {
  return config;
}
var MachineStatus = ((MachineStatus2) => {
  MachineStatus2["NotStarted"] = "Not Started";
  MachineStatus2["Started"] = "Started";
  MachineStatus2["Stopped"] = "Stopped";
  return MachineStatus2;
})(MachineStatus || {});
var INIT_STATE = "__init__";
function createScope(props2) {
  const getRootNode = () => props2.getRootNode?.() ?? document;
  const getDoc = () => getDocument(getRootNode());
  const getWin = () => getDoc().defaultView ?? window;
  const getActiveElementFn = () => getActiveElement(getRootNode());
  const getById = (id) => getRootNode().getElementById(id);
  return {
    ...props2,
    getRootNode,
    getDoc,
    getWin,
    getActiveElement: getActiveElementFn,
    isActiveElement,
    getById
  };
}

// node_modules/@ark-ui/react/dist/components/factory.js
var import_react = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/utils/compose-refs.js
function composeRefs(...refs) {
  return (node) => {
    const cleanUps = [];
    for (const ref of refs) {
      if (typeof ref === "function") {
        const cb = ref(node);
        if (typeof cb === "function") {
          cleanUps.push(cb);
        }
      } else if (ref) {
        ref.current = node;
      }
    }
    if (cleanUps.length) {
      return () => {
        for (const cleanUp of cleanUps) {
          cleanUp();
        }
      };
    }
  };
}

// node_modules/@ark-ui/react/dist/components/factory.js
function getRef(element) {
  let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = Object.getOwnPropertyDescriptor(element, "ref")?.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}
var withAsChild = (Component) => {
  const Comp = (0, import_react.memo)(
    (0, import_react.forwardRef)((props2, ref) => {
      const { asChild, children, ...restProps } = props2;
      if (!asChild) {
        return (0, import_react.createElement)(Component, { ...restProps, ref }, children);
      }
      if (!(0, import_react.isValidElement)(children)) {
        return null;
      }
      const onlyChild = import_react.Children.only(children);
      const childRef = getRef(onlyChild);
      return (0, import_react.cloneElement)(onlyChild, {
        ...mergeProps(restProps, onlyChild.props),
        ref: ref ? composeRefs(ref, childRef) : childRef
      });
    })
  );
  Comp.displayName = Component.displayName || Component.name;
  return Comp;
};
var jsxFactory = () => {
  const cache = /* @__PURE__ */ new Map();
  return new Proxy(withAsChild, {
    apply(_target, _thisArg, argArray) {
      return withAsChild(argArray[0]);
    },
    get(_, element) {
      const asElement = element;
      if (!cache.has(asElement)) {
        cache.set(asElement, withAsChild(asElement));
      }
      return cache.get(asElement);
    }
  });
};
var ark = jsxFactory();

// node_modules/@ark-ui/react/node_modules/@zag-js/anatomy/dist/index.mjs
var createAnatomy = (name, parts4 = []) => ({
  parts: (...values) => {
    if (isEmpty(parts4)) {
      return createAnatomy(name, values);
    }
    throw new Error("createAnatomy().parts(...) should only be called once. Did you mean to use .extendWith(...) ?");
  },
  extendWith: (...values) => createAnatomy(name, [...parts4, ...values]),
  omit: (...values) => createAnatomy(name, parts4.filter((part) => !values.includes(part))),
  rename: (newName) => createAnatomy(newName, parts4),
  keys: () => parts4,
  build: () => [...new Set(parts4)].reduce(
    (prev, part) => Object.assign(prev, {
      [part]: {
        selector: [
          `&[data-scope="${toKebabCase(name)}"][data-part="${toKebabCase(part)}"]`,
          `& [data-scope="${toKebabCase(name)}"][data-part="${toKebabCase(part)}"]`
        ].join(", "),
        attrs: { "data-scope": toKebabCase(name), "data-part": toKebabCase(part) }
      }
    }),
    {}
  )
});
var toKebabCase = (value) => value.replace(/([A-Z])([A-Z])/g, "$1-$2").replace(/([a-z])([A-Z])/g, "$1-$2").replace(/[\s_]+/g, "-").toLowerCase();
var isEmpty = (v) => v.length === 0;

// node_modules/@ark-ui/react/node_modules/@zag-js/utils/dist/index.mjs
var add = (v, ...items) => v.concat(items);
var remove = (v, ...items) => v.filter((t) => !items.includes(t));
var uniq = (v) => Array.from(new Set(v));
function nextIndex(v, idx, opts = {}) {
  const { step = 1, loop = true } = opts;
  const next2 = idx + step;
  const len = v.length;
  const last2 = len - 1;
  if (idx === -1) return step > 0 ? 0 : last2;
  if (next2 < 0) return loop ? last2 : 0;
  if (next2 >= len) return loop ? 0 : idx > len ? len : idx;
  return next2;
}
function prevIndex(v, idx, opts = {}) {
  const { step = 1, loop = true } = opts;
  return nextIndex(v, idx, { step: -step, loop });
}
var isArray = (v) => Array.isArray(v);
var isObjectLike = (v) => v != null && typeof v === "object";
var isObject2 = (v) => isObjectLike(v) && !isArray(v);
var isFunction = (v) => typeof v === "function";
var hasProp = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
var fnToString2 = Function.prototype.toString;
var objectCtorString2 = fnToString2.call(Object);
var callAll2 = (...fns) => (...a) => {
  fns.forEach(function(fn) {
    fn?.(...a);
  });
};
function throttle(fn, wait = 0) {
  let lastCall = 0;
  let timeout = null;
  return ((...args) => {
    const now = Date.now();
    const timeSinceLastCall = now - lastCall;
    if (timeSinceLastCall >= wait) {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
      fn(...args);
      lastCall = now;
    } else if (!timeout) {
      timeout = setTimeout(() => {
        fn(...args);
        lastCall = Date.now();
        timeout = null;
      }, wait - timeSinceLastCall);
    }
  });
}
var { floor: floor2, abs: abs2, round: round2, min: min2, max: max2, pow: pow2, sign: sign2 } = Math;
var isNaN = (v) => Number.isNaN(v);
var nan = (v) => isNaN(v) ? 0 : v;
var clampValue = (v, vmin, vmax) => min2(max2(nan(v), vmin), vmax);
function splitProps(props2, keys) {
  const rest = {};
  const result = {};
  const keySet = new Set(keys);
  const ownKeys = Reflect.ownKeys(props2);
  for (const key of ownKeys) {
    if (keySet.has(key)) {
      result[key] = props2[key];
    } else {
      rest[key] = props2[key];
    }
  }
  return [result, rest];
}
var createSplitProps = (keys) => {
  return function split(props2) {
    return splitProps(props2, keys);
  };
};
var _tick2;
_tick2 = /* @__PURE__ */ new WeakMap();
function ensureProps(props2, keys, scope) {
  let missingKeys = [];
  for (const key of keys) {
    if (props2[key] == null) missingKeys.push(key);
  }
  if (missingKeys.length > 0)
    throw new Error(`[zag-js${scope ? ` > ${scope}` : ""}] missing required props: ${missingKeys.join(", ")}`);
}

// node_modules/@zag-js/scroll-snap/dist/index.mjs
var getDirection = (element) => getComputedStyle2(element).direction;
function getScrollPadding(element) {
  const style = getComputedStyle2(element);
  const rect = element.getBoundingClientRect();
  let xBeforeRaw = style.getPropertyValue("scroll-padding-left").replace("auto", "0px");
  let yBeforeRaw = style.getPropertyValue("scroll-padding-top").replace("auto", "0px");
  let xAfterRaw = style.getPropertyValue("scroll-padding-right").replace("auto", "0px");
  let yAfterRaw = style.getPropertyValue("scroll-padding-bottom").replace("auto", "0px");
  function convert(raw, size) {
    let n = parseFloat(raw);
    if (/%/.test(raw)) {
      n /= 100;
      n *= size;
    }
    return Number.isNaN(n) ? 0 : n;
  }
  let xBefore = convert(xBeforeRaw, rect.width);
  let yBefore = convert(yBeforeRaw, rect.height);
  let xAfter = convert(xAfterRaw, rect.width);
  let yAfter = convert(yAfterRaw, rect.height);
  return {
    x: { before: xBefore, after: xAfter },
    y: { before: yBefore, after: yAfter }
  };
}
function isRectIntersecting(a, b, axis = "both") {
  return axis === "x" && a.right >= b.left && a.left <= b.right || axis === "y" && a.bottom >= b.top && a.top <= b.bottom || axis === "both" && a.right >= b.left && a.left <= b.right && a.bottom >= b.top && a.top <= b.bottom;
}
function getDescendants(parent) {
  let children = [];
  for (const child of parent.children) {
    children = children.concat(child, getDescendants(child));
  }
  return children;
}
function getSnapPositions(parent, subtree = false) {
  const parentRect = parent.getBoundingClientRect();
  const dir = getDirection(parent);
  const isRtl = dir === "rtl";
  const positions = {
    x: { start: [], center: [], end: [] },
    y: { start: [], center: [], end: [] }
  };
  const children = subtree ? getDescendants(parent) : parent.children;
  for (const axis of ["x", "y"]) {
    const orthogonalAxis = axis === "x" ? "y" : "x";
    const axisStart = axis === "x" ? "left" : "top";
    const axisEnd = axis === "x" ? "right" : "bottom";
    const axisSize = axis === "x" ? "width" : "height";
    const axisScroll = axis === "x" ? "scrollLeft" : "scrollTop";
    const useRtlCalc = isRtl && axis === "x";
    for (const child of children) {
      const childRect = child.getBoundingClientRect();
      if (!isRectIntersecting(parentRect, childRect, orthogonalAxis)) {
        continue;
      }
      const childStyle = getComputedStyle2(child);
      let [childAlignY, childAlignX] = childStyle.getPropertyValue("scroll-snap-align").split(" ");
      if (typeof childAlignX === "undefined") {
        childAlignX = childAlignY;
      }
      const childAlign = axis === "x" ? childAlignX : childAlignY;
      let childOffsetStart;
      let childOffsetEnd;
      let childOffsetCenter;
      if (useRtlCalc) {
        const scrollOffset = Math.abs(parent[axisScroll]);
        const rightOffset = parentRect[axisEnd] - childRect[axisEnd] + scrollOffset;
        childOffsetStart = rightOffset;
        childOffsetEnd = rightOffset + childRect[axisSize];
        childOffsetCenter = rightOffset + childRect[axisSize] / 2;
      } else {
        childOffsetStart = childRect[axisStart] - parentRect[axisStart] + parent[axisScroll];
        childOffsetEnd = childOffsetStart + childRect[axisSize];
        childOffsetCenter = childOffsetStart + childRect[axisSize] / 2;
      }
      switch (childAlign) {
        case "none":
          break;
        case "start":
          positions[axis].start.push({ node: child, position: childOffsetStart });
          break;
        case "center":
          positions[axis].center.push({ node: child, position: childOffsetCenter });
          break;
        case "end":
          positions[axis].end.push({ node: child, position: childOffsetEnd });
          break;
      }
    }
  }
  return positions;
}
function getScrollSnapPositions(element) {
  const dir = getDirection(element);
  const rect = element.getBoundingClientRect();
  const scrollPadding = getScrollPadding(element);
  const snapPositions = getSnapPositions(element);
  const maxScroll = {
    x: element.scrollWidth - element.offsetWidth,
    y: element.scrollHeight - element.offsetHeight
  };
  const isRtl = dir === "rtl";
  const usesNegativeScrollLeft = isRtl && element.scrollLeft <= 0;
  let xPositions;
  if (isRtl) {
    xPositions = uniq2(
      [
        ...snapPositions.x.start.map((v) => v.position - scrollPadding.x.after),
        ...snapPositions.x.center.map((v) => v.position - rect.width / 2),
        ...snapPositions.x.end.map((v) => v.position - rect.width + scrollPadding.x.before)
      ].map(clamp(0, maxScroll.x))
    );
    if (usesNegativeScrollLeft) {
      xPositions = xPositions.map((pos) => -pos);
    }
  } else {
    xPositions = uniq2(
      [
        ...snapPositions.x.start.map((v) => v.position - scrollPadding.x.before),
        ...snapPositions.x.center.map((v) => v.position - rect.width / 2),
        ...snapPositions.x.end.map((v) => v.position - rect.width + scrollPadding.x.after)
      ].map(clamp(0, maxScroll.x))
    );
  }
  return {
    x: xPositions,
    y: uniq2(
      [
        ...snapPositions.y.start.map((v) => v.position - scrollPadding.y.before),
        ...snapPositions.y.center.map((v) => v.position - rect.height / 2),
        ...snapPositions.y.end.map((v) => v.position - rect.height + scrollPadding.y.after)
      ].map(clamp(0, maxScroll.y))
    )
  };
}
function findSnapPoint(parent, axis, predicate) {
  const dir = getDirection(parent);
  const scrollPadding = getScrollPadding(parent);
  const snapPositions = getSnapPositions(parent);
  const items = [...snapPositions[axis].start, ...snapPositions[axis].center, ...snapPositions[axis].end];
  const isRtl = dir === "rtl";
  const usesNegativeScrollLeft = isRtl && axis === "x" && parent.scrollLeft <= 0;
  for (const item of items) {
    if (predicate(item.node)) {
      let position;
      if (axis === "x" && isRtl) {
        position = item.position - scrollPadding.x.after;
        if (usesNegativeScrollLeft) {
          position = -position;
        }
      } else {
        position = item.position - (axis === "x" ? scrollPadding.x.before : scrollPadding.y.before);
      }
      return position;
    }
  }
}
var uniq2 = (arr) => [...new Set(arr)];
var clamp = (min4, max4) => (value) => Math.max(min4, Math.min(max4, value));

// node_modules/@zag-js/types/dist/index.mjs
function createNormalizer(fn) {
  return new Proxy({}, {
    get(_target, key) {
      if (key === "style")
        return (props2) => {
          return fn({ style: props2 }).style;
        };
      return fn;
    }
  });
}
var createProps = () => (props2) => Array.from(new Set(props2));

// node_modules/@ark-ui/react/node_modules/@zag-js/carousel/dist/index.mjs
var anatomy = createAnatomy("carousel").parts(
  "root",
  "itemGroup",
  "item",
  "control",
  "nextTrigger",
  "prevTrigger",
  "indicatorGroup",
  "indicator",
  "autoplayTrigger",
  "progressText"
);
var parts = anatomy.build();
var getRootId = (ctx) => ctx.ids?.root ?? `carousel:${ctx.id}`;
var getItemId = (ctx, index) => ctx.ids?.item?.(index) ?? `carousel:${ctx.id}:item:${index}`;
var getItemGroupId = (ctx) => ctx.ids?.itemGroup ?? `carousel:${ctx.id}:item-group`;
var getNextTriggerId = (ctx) => ctx.ids?.nextTrigger ?? `carousel:${ctx.id}:next-trigger`;
var getPrevTriggerId = (ctx) => ctx.ids?.prevTrigger ?? `carousel:${ctx.id}:prev-trigger`;
var getIndicatorGroupId = (ctx) => ctx.ids?.indicatorGroup ?? `carousel:${ctx.id}:indicator-group`;
var getIndicatorId = (ctx, index) => ctx.ids?.indicator?.(index) ?? `carousel:${ctx.id}:indicator:${index}`;
var getItemGroupEl = (ctx) => ctx.getById(getItemGroupId(ctx));
var getItemEls = (ctx) => queryAll(getItemGroupEl(ctx), `[data-part=item]`);
var getIndicatorEl = (ctx, page) => ctx.getById(getIndicatorId(ctx, page));
var syncTabIndex = (ctx) => {
  const el = getItemGroupEl(ctx);
  if (!el) return;
  const tabbables = getTabbables(el);
  el.setAttribute("tabindex", tabbables.length > 0 ? "-1" : "0");
};
function connect(service, normalize) {
  const { state: state2, context, computed, send, scope, prop } = service;
  const isPlaying = state2.matches("autoplay");
  const isDragging = state2.matches("dragging");
  const canScrollNext = computed("canScrollNext");
  const canScrollPrev = computed("canScrollPrev");
  const horizontal = computed("isHorizontal");
  const autoSize = prop("autoSize");
  const pageSnapPoints = Array.from(context.get("pageSnapPoints"));
  const page = context.get("page");
  const slidesPerPage = prop("slidesPerPage");
  const padding = prop("padding");
  const translations = prop("translations");
  return {
    isPlaying,
    isDragging,
    page,
    pageSnapPoints,
    canScrollNext,
    canScrollPrev,
    getProgress() {
      return page / pageSnapPoints.length;
    },
    getProgressText() {
      const details = { page: page + 1, totalPages: pageSnapPoints.length };
      return translations.progressText?.(details) ?? "";
    },
    scrollToIndex(index, instant) {
      send({ type: "INDEX.SET", index, instant });
    },
    scrollTo(index, instant) {
      send({ type: "PAGE.SET", index, instant });
    },
    scrollNext(instant) {
      send({ type: "PAGE.NEXT", instant });
    },
    scrollPrev(instant) {
      send({ type: "PAGE.PREV", instant });
    },
    play() {
      send({ type: "AUTOPLAY.START" });
    },
    pause() {
      send({ type: "AUTOPLAY.PAUSE" });
    },
    isInView(index) {
      return Array.from(context.get("slidesInView")).includes(index);
    },
    refresh() {
      send({ type: "SNAP.REFRESH" });
    },
    getRootProps() {
      return normalize.element({
        ...parts.root.attrs,
        id: getRootId(scope),
        role: "region",
        "aria-roledescription": "carousel",
        "data-orientation": prop("orientation"),
        dir: prop("dir"),
        style: {
          "--slides-per-page": slidesPerPage,
          "--slide-spacing": prop("spacing"),
          "--slide-item-size": autoSize ? "auto" : "calc(100% / var(--slides-per-page) - var(--slide-spacing) * (var(--slides-per-page) - 1) / var(--slides-per-page))"
        }
      });
    },
    getItemGroupProps() {
      return normalize.element({
        ...parts.itemGroup.attrs,
        id: getItemGroupId(scope),
        "data-orientation": prop("orientation"),
        "data-dragging": dataAttr(isDragging),
        dir: prop("dir"),
        "aria-live": isPlaying ? "off" : "polite",
        onFocus(event) {
          if (!contains(event.currentTarget, getEventTarget(event))) return;
          send({ type: "VIEWPORT.FOCUS" });
        },
        onBlur(event) {
          if (contains(event.currentTarget, event.relatedTarget)) return;
          send({ type: "VIEWPORT.BLUR" });
        },
        onMouseDown(event) {
          if (event.defaultPrevented) return;
          if (!prop("allowMouseDrag")) return;
          if (!isLeftClick(event)) return;
          const target = getEventTarget(event);
          if (isFocusable(target) && target !== event.currentTarget) return;
          event.preventDefault();
          send({ type: "DRAGGING.START" });
        },
        onWheel: throttle((event) => {
          const axis = prop("orientation") === "horizontal" ? "deltaX" : "deltaY";
          const isScrollingLeft = event[axis] < 0;
          if (isScrollingLeft && !computed("canScrollPrev")) return;
          const isScrollingRight = event[axis] > 0;
          if (isScrollingRight && !computed("canScrollNext")) return;
          send({ type: "USER.SCROLL" });
        }, 150),
        onTouchStart() {
          send({ type: "USER.SCROLL" });
        },
        style: {
          display: autoSize ? "flex" : "grid",
          gap: "var(--slide-spacing)",
          scrollSnapType: [horizontal ? "x" : "y", prop("snapType")].join(" "),
          gridAutoFlow: horizontal ? "column" : "row",
          scrollbarWidth: "none",
          overscrollBehaviorX: "contain",
          [horizontal ? "gridAutoColumns" : "gridAutoRows"]: autoSize ? void 0 : "var(--slide-item-size)",
          [horizontal ? "scrollPaddingInline" : "scrollPaddingBlock"]: padding,
          [horizontal ? "paddingInline" : "paddingBlock"]: padding,
          [horizontal ? "overflowX" : "overflowY"]: "auto"
        }
      });
    },
    getItemProps(props2) {
      const isInView = context.get("slidesInView").includes(props2.index);
      return normalize.element({
        ...parts.item.attrs,
        id: getItemId(scope, props2.index),
        dir: prop("dir"),
        role: "group",
        "data-index": props2.index,
        "data-inview": dataAttr(isInView),
        "aria-roledescription": "slide",
        "data-orientation": prop("orientation"),
        "aria-label": translations.item(props2.index, prop("slideCount")),
        "aria-hidden": ariaAttr(!isInView),
        style: {
          flex: "0 0 auto",
          [horizontal ? "maxWidth" : "maxHeight"]: "100%",
          scrollSnapAlign: (() => {
            const snapAlign = props2.snapAlign ?? "start";
            const slidesPerMove = prop("slidesPerMove");
            const perMove = slidesPerMove === "auto" ? Math.floor(prop("slidesPerPage")) : slidesPerMove;
            const shouldSnap = (props2.index + perMove) % perMove === 0;
            return shouldSnap ? snapAlign : void 0;
          })()
        }
      });
    },
    getControlProps() {
      return normalize.element({
        ...parts.control.attrs,
        "data-orientation": prop("orientation")
      });
    },
    getPrevTriggerProps() {
      return normalize.button({
        ...parts.prevTrigger.attrs,
        id: getPrevTriggerId(scope),
        type: "button",
        disabled: !canScrollPrev,
        dir: prop("dir"),
        "aria-label": translations.prevTrigger,
        "data-orientation": prop("orientation"),
        "aria-controls": getItemGroupId(scope),
        onClick(event) {
          if (event.defaultPrevented) return;
          send({ type: "PAGE.PREV", src: "trigger" });
        }
      });
    },
    getNextTriggerProps() {
      return normalize.button({
        ...parts.nextTrigger.attrs,
        dir: prop("dir"),
        id: getNextTriggerId(scope),
        type: "button",
        "aria-label": translations.nextTrigger,
        "data-orientation": prop("orientation"),
        "aria-controls": getItemGroupId(scope),
        disabled: !canScrollNext,
        onClick(event) {
          if (event.defaultPrevented) return;
          send({ type: "PAGE.NEXT", src: "trigger" });
        }
      });
    },
    getIndicatorGroupProps() {
      return normalize.element({
        ...parts.indicatorGroup.attrs,
        dir: prop("dir"),
        id: getIndicatorGroupId(scope),
        "data-orientation": prop("orientation"),
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          const src = "indicator";
          const keyMap2 = {
            ArrowDown(event2) {
              if (horizontal) return;
              send({ type: "PAGE.NEXT", src });
              event2.preventDefault();
            },
            ArrowUp(event2) {
              if (horizontal) return;
              send({ type: "PAGE.PREV", src });
              event2.preventDefault();
            },
            ArrowRight(event2) {
              if (!horizontal) return;
              send({ type: "PAGE.NEXT", src });
              event2.preventDefault();
            },
            ArrowLeft(event2) {
              if (!horizontal) return;
              send({ type: "PAGE.PREV", src });
              event2.preventDefault();
            },
            Home(event2) {
              send({ type: "PAGE.SET", index: 0, src });
              event2.preventDefault();
            },
            End(event2) {
              send({ type: "PAGE.SET", index: pageSnapPoints.length - 1, src });
              event2.preventDefault();
            }
          };
          const key = getEventKey(event, {
            dir: prop("dir"),
            orientation: prop("orientation")
          });
          const exec = keyMap2[key];
          exec?.(event);
        }
      });
    },
    getIndicatorProps(props2) {
      return normalize.button({
        ...parts.indicator.attrs,
        dir: prop("dir"),
        id: getIndicatorId(scope, props2.index),
        type: "button",
        "data-orientation": prop("orientation"),
        "data-index": props2.index,
        "data-readonly": dataAttr(props2.readOnly),
        "data-current": dataAttr(props2.index === page),
        "aria-label": translations.indicator(props2.index),
        onClick(event) {
          if (event.defaultPrevented) return;
          if (props2.readOnly) return;
          send({ type: "PAGE.SET", index: props2.index, src: "indicator" });
        }
      });
    },
    getAutoplayTriggerProps() {
      return normalize.button({
        ...parts.autoplayTrigger.attrs,
        type: "button",
        "data-orientation": prop("orientation"),
        "data-pressed": dataAttr(isPlaying),
        "aria-label": isPlaying ? translations.autoplayStop : translations.autoplayStart,
        onClick(event) {
          if (event.defaultPrevented) return;
          send({ type: isPlaying ? "AUTOPLAY.PAUSE" : "AUTOPLAY.START" });
        }
      });
    },
    getProgressTextProps() {
      return normalize.element({
        ...parts.progressText.attrs
      });
    }
  };
}
var machine = createMachine({
  props({ props: props2 }) {
    ensureProps(props2, ["slideCount"], "carousel");
    return {
      dir: "ltr",
      defaultPage: 0,
      orientation: "horizontal",
      snapType: "mandatory",
      loop: !!props2.autoplay,
      slidesPerPage: 1,
      slidesPerMove: "auto",
      spacing: "0px",
      autoplay: false,
      allowMouseDrag: false,
      inViewThreshold: 0.6,
      autoSize: false,
      ...props2,
      translations: {
        nextTrigger: "Next slide",
        prevTrigger: "Previous slide",
        indicator: (index) => `Go to slide ${index + 1}`,
        item: (index, count) => `${index + 1} of ${count}`,
        autoplayStart: "Start slide rotation",
        autoplayStop: "Stop slide rotation",
        progressText: ({ page, totalPages }) => `${page} / ${totalPages}`,
        ...props2.translations
      }
    };
  },
  refs() {
    return {
      timeoutRef: void 0
    };
  },
  initialState({ prop }) {
    return prop("autoplay") ? "autoplay" : "idle";
  },
  context({ prop, bindable, getContext }) {
    return {
      page: bindable(() => ({
        defaultValue: prop("defaultPage"),
        value: prop("page"),
        onChange(page) {
          const ctx = getContext();
          const pageSnapPoints = ctx.get("pageSnapPoints");
          prop("onPageChange")?.({ page, pageSnapPoint: pageSnapPoints[page] });
        }
      })),
      pageSnapPoints: bindable(() => {
        return {
          defaultValue: prop("autoSize") ? Array.from({ length: prop("slideCount") }, (_, i) => i) : getPageSnapPoints(prop("slideCount"), prop("slidesPerMove"), prop("slidesPerPage"))
        };
      }),
      slidesInView: bindable(() => ({
        defaultValue: []
      }))
    };
  },
  computed: {
    isRtl: ({ prop }) => prop("dir") === "rtl",
    isHorizontal: ({ prop }) => prop("orientation") === "horizontal",
    canScrollNext: ({ prop, context }) => prop("loop") || context.get("page") < context.get("pageSnapPoints").length - 1,
    canScrollPrev: ({ prop, context }) => prop("loop") || context.get("page") > 0,
    autoplayInterval: ({ prop }) => {
      const autoplay = prop("autoplay");
      return isObject2(autoplay) ? autoplay.delay : 4e3;
    }
  },
  watch({ track, action, context, prop, send }) {
    track([() => prop("slidesPerPage"), () => prop("slidesPerMove")], () => {
      action(["setSnapPoints"]);
    });
    track([() => context.get("page")], () => {
      action(["scrollToPage", "focusIndicatorEl"]);
    });
    track([() => prop("orientation"), () => prop("autoSize"), () => prop("dir")], () => {
      action(["setSnapPoints", "scrollToPage"]);
    });
    track([() => prop("slideCount")], () => {
      send({ type: "SNAP.REFRESH", src: "slide.count" });
    });
    track([() => !!prop("autoplay")], () => {
      send({ type: prop("autoplay") ? "AUTOPLAY.START" : "AUTOPLAY.PAUSE", src: "autoplay.prop.change" });
    });
  },
  on: {
    "PAGE.NEXT": {
      target: "idle",
      actions: ["clearScrollEndTimer", "setNextPage"]
    },
    "PAGE.PREV": {
      target: "idle",
      actions: ["clearScrollEndTimer", "setPrevPage"]
    },
    "PAGE.SET": {
      target: "idle",
      actions: ["clearScrollEndTimer", "setPage"]
    },
    "INDEX.SET": {
      target: "idle",
      actions: ["clearScrollEndTimer", "setMatchingPage"]
    },
    "SNAP.REFRESH": {
      actions: ["setSnapPoints", "clampPage"]
    },
    "PAGE.SCROLL": {
      actions: ["scrollToPage"]
    }
  },
  effects: ["trackSlideMutation", "trackSlideIntersections", "trackSlideResize"],
  entry: ["setSnapPoints", "setPage"],
  exit: ["clearScrollEndTimer"],
  states: {
    idle: {
      on: {
        "DRAGGING.START": {
          target: "dragging",
          actions: ["invokeDragStart"]
        },
        "AUTOPLAY.START": {
          target: "autoplay",
          actions: ["invokeAutoplayStart"]
        },
        "USER.SCROLL": {
          target: "userScroll"
        },
        "VIEWPORT.FOCUS": {
          target: "focus"
        }
      }
    },
    focus: {
      effects: ["trackKeyboardScroll"],
      on: {
        "VIEWPORT.BLUR": {
          target: "idle"
        },
        "PAGE.NEXT": {
          actions: ["clearScrollEndTimer", "setNextPage"]
        },
        "PAGE.PREV": {
          actions: ["clearScrollEndTimer", "setPrevPage"]
        },
        "PAGE.SET": {
          actions: ["clearScrollEndTimer", "setPage"]
        },
        "INDEX.SET": {
          actions: ["clearScrollEndTimer", "setMatchingPage"]
        },
        "USER.SCROLL": {
          target: "userScroll"
        }
      }
    },
    dragging: {
      effects: ["trackPointerMove"],
      entry: ["disableScrollSnap"],
      on: {
        DRAGGING: {
          actions: ["scrollSlides", "invokeDragging"]
        },
        "DRAGGING.END": {
          target: "idle",
          actions: ["endDragging", "invokeDraggingEnd"]
        }
      }
    },
    userScroll: {
      effects: ["trackScroll"],
      on: {
        "DRAGGING.START": {
          target: "dragging",
          actions: ["invokeDragStart"]
        },
        "SCROLL.END": [
          {
            guard: "isFocused",
            target: "focus",
            actions: ["setClosestPage"]
          },
          {
            target: "idle",
            actions: ["setClosestPage"]
          }
        ]
      }
    },
    autoplay: {
      effects: ["trackDocumentVisibility", "trackScroll", "autoUpdateSlide"],
      exit: ["invokeAutoplayEnd"],
      on: {
        "AUTOPLAY.TICK": {
          actions: ["setNextPage", "invokeAutoplay"]
        },
        "DRAGGING.START": {
          target: "dragging",
          actions: ["invokeDragStart"]
        },
        "AUTOPLAY.PAUSE": {
          target: "idle"
        }
      }
    }
  },
  implementations: {
    guards: {
      isFocused: ({ scope }) => scope.isActiveElement(getItemGroupEl(scope))
    },
    effects: {
      autoUpdateSlide({ computed, send }) {
        const id = setInterval(() => {
          send({
            type: computed("canScrollNext") ? "AUTOPLAY.TICK" : "AUTOPLAY.PAUSE",
            src: "autoplay.interval"
          });
        }, computed("autoplayInterval"));
        return () => clearInterval(id);
      },
      trackSlideMutation({ scope, send }) {
        const el = getItemGroupEl(scope);
        if (!el) return;
        const win = scope.getWin();
        const observer = new win.MutationObserver(() => {
          send({ type: "SNAP.REFRESH", src: "slide.mutation" });
          syncTabIndex(scope);
        });
        syncTabIndex(scope);
        observer.observe(el, { childList: true, subtree: true });
        return () => observer.disconnect();
      },
      trackSlideResize({ scope, send }) {
        const el = getItemGroupEl(scope);
        if (!el) return;
        const exec = () => {
          send({ type: "SNAP.REFRESH", src: "slide.resize" });
        };
        raf(() => {
          exec();
          raf(() => {
            send({ type: "PAGE.SCROLL", instant: true });
          });
        });
        const itemEls = getItemEls(scope);
        itemEls.forEach(exec);
        const cleanups = itemEls.map((el2) => resizeObserverBorderBox.observe(el2, exec));
        return callAll2(...cleanups);
      },
      trackSlideIntersections({ scope, prop, context }) {
        const el = getItemGroupEl(scope);
        const win = scope.getWin();
        const observer = new win.IntersectionObserver(
          (entries) => {
            const slidesInView = entries.reduce((acc, entry) => {
              const target = entry.target;
              const index = Number(target.dataset.index ?? "-1");
              if (index == null || Number.isNaN(index) || index === -1) return acc;
              return entry.isIntersecting ? add(acc, index) : remove(acc, index);
            }, context.get("slidesInView"));
            context.set("slidesInView", uniq(slidesInView));
          },
          {
            root: el,
            threshold: prop("inViewThreshold")
          }
        );
        getItemEls(scope).forEach((slide) => observer.observe(slide));
        return () => observer.disconnect();
      },
      trackScroll({ send, refs, scope }) {
        const el = getItemGroupEl(scope);
        if (!el) return;
        const onScroll = () => {
          clearTimeout(refs.get("timeoutRef"));
          refs.set("timeoutRef", void 0);
          refs.set(
            "timeoutRef",
            setTimeout(() => {
              send({ type: "SCROLL.END" });
            }, 150)
          );
        };
        return addDomEvent(el, "scroll", onScroll, { passive: true });
      },
      trackDocumentVisibility({ scope, send }) {
        const doc = scope.getDoc();
        const onVisibilityChange = () => {
          if (doc.visibilityState === "visible") return;
          send({ type: "AUTOPLAY.PAUSE", src: "doc.hidden" });
        };
        return addDomEvent(doc, "visibilitychange", onVisibilityChange);
      },
      trackPointerMove({ scope, send }) {
        const doc = scope.getDoc();
        return trackPointerMove(doc, {
          onPointerMove({ event }) {
            send({ type: "DRAGGING", left: -event.movementX, top: -event.movementY });
          },
          onPointerUp() {
            send({ type: "DRAGGING.END" });
          }
        });
      },
      trackKeyboardScroll({ scope, send, context }) {
        const win = scope.getWin();
        const onKeyDown = (event) => {
          switch (event.key) {
            case "ArrowRight":
              event.preventDefault();
              send({ type: "PAGE.NEXT" });
              break;
            case "ArrowLeft":
              event.preventDefault();
              send({ type: "PAGE.PREV" });
              break;
            case "Home":
              event.preventDefault();
              send({ type: "PAGE.SET", index: 0 });
              break;
            case "End":
              event.preventDefault();
              send({ type: "PAGE.SET", index: context.get("pageSnapPoints").length - 1 });
          }
        };
        return addDomEvent(win, "keydown", onKeyDown, { capture: true });
      }
    },
    actions: {
      clearScrollEndTimer({ refs }) {
        if (refs.get("timeoutRef") == null) return;
        clearTimeout(refs.get("timeoutRef"));
        refs.set("timeoutRef", void 0);
      },
      scrollToPage({ context, event, scope, computed, flush: flush2 }) {
        const behavior = event.instant ? "instant" : "smooth";
        const index = clampValue(event.index ?? context.get("page"), 0, context.get("pageSnapPoints").length - 1);
        const el = getItemGroupEl(scope);
        if (!el) return;
        const axis = computed("isHorizontal") ? "left" : "top";
        flush2(() => {
          el.scrollTo({ [axis]: context.get("pageSnapPoints")[index], behavior });
        });
      },
      setClosestPage({ context, scope, computed }) {
        const el = getItemGroupEl(scope);
        if (!el) return;
        const scrollPosition = computed("isHorizontal") ? el.scrollLeft : el.scrollTop;
        const page = context.get("pageSnapPoints").findIndex((point) => Math.abs(point - scrollPosition) < 1);
        if (page === -1) return;
        context.set("page", page);
      },
      setNextPage({ context, prop, state: state2 }) {
        const loop = state2.matches("autoplay") || prop("loop");
        const page = nextIndex(context.get("pageSnapPoints"), context.get("page"), { loop });
        context.set("page", page);
      },
      setPrevPage({ context, prop, state: state2 }) {
        const loop = state2.matches("autoplay") || prop("loop");
        const page = prevIndex(context.get("pageSnapPoints"), context.get("page"), { loop });
        context.set("page", page);
      },
      setMatchingPage({ context, event, computed, scope }) {
        const el = getItemGroupEl(scope);
        if (!el) return;
        const snapPoint = findSnapPoint(
          el,
          computed("isHorizontal") ? "x" : "y",
          (node) => node.dataset.index === event.index.toString()
        );
        if (snapPoint == null) return;
        const page = context.get("pageSnapPoints").findIndex((point) => Math.abs(point - snapPoint) < 1);
        context.set("page", page);
      },
      setPage({ context, event }) {
        const page = event.index ?? context.get("page");
        context.set("page", page);
      },
      clampPage({ context }) {
        const index = clampValue(context.get("page"), 0, context.get("pageSnapPoints").length - 1);
        context.set("page", index);
      },
      setSnapPoints({ context, computed, scope }) {
        const el = getItemGroupEl(scope);
        if (!el) return;
        const scrollSnapPoints = getScrollSnapPositions(el);
        context.set("pageSnapPoints", computed("isHorizontal") ? scrollSnapPoints.x : scrollSnapPoints.y);
      },
      disableScrollSnap({ scope }) {
        const el = getItemGroupEl(scope);
        if (!el) return;
        const styles = getComputedStyle(el);
        el.dataset.scrollSnapType = styles.getPropertyValue("scroll-snap-type");
        el.style.setProperty("scroll-snap-type", "none");
      },
      scrollSlides({ scope, event }) {
        const el = getItemGroupEl(scope);
        el?.scrollBy({ left: event.left, top: event.top, behavior: "instant" });
      },
      endDragging({ scope, context, computed }) {
        const el = getItemGroupEl(scope);
        if (!el) return;
        const isHorizontal = computed("isHorizontal");
        const scrollPos = isHorizontal ? el.scrollLeft : el.scrollTop;
        const snapPoints = context.get("pageSnapPoints");
        const closest = snapPoints.reduce((closest2, curr) => {
          return Math.abs(curr - scrollPos) < Math.abs(closest2 - scrollPos) ? curr : closest2;
        }, snapPoints[0]);
        raf(() => {
          el.scrollTo({
            left: isHorizontal ? closest : el.scrollLeft,
            top: isHorizontal ? el.scrollTop : closest,
            behavior: "smooth"
          });
          context.set("page", snapPoints.indexOf(closest));
          const scrollSnapType = el.dataset.scrollSnapType;
          if (scrollSnapType) {
            el.style.setProperty("scroll-snap-type", scrollSnapType);
            delete el.dataset.scrollSnapType;
          }
        });
      },
      focusIndicatorEl({ context, event, scope }) {
        if (event.src !== "indicator") return;
        const el = getIndicatorEl(scope, context.get("page"));
        if (!el) return;
        raf(() => el.focus({ preventScroll: true }));
      },
      invokeDragStart({ context, prop }) {
        prop("onDragStatusChange")?.({ type: "dragging.start", isDragging: true, page: context.get("page") });
      },
      invokeDragging({ context, prop }) {
        prop("onDragStatusChange")?.({ type: "dragging", isDragging: true, page: context.get("page") });
      },
      invokeDraggingEnd({ context, prop }) {
        prop("onDragStatusChange")?.({ type: "dragging.end", isDragging: false, page: context.get("page") });
      },
      invokeAutoplay({ context, prop }) {
        prop("onAutoplayStatusChange")?.({ type: "autoplay", isPlaying: true, page: context.get("page") });
      },
      invokeAutoplayStart({ context, prop }) {
        prop("onAutoplayStatusChange")?.({ type: "autoplay.start", isPlaying: true, page: context.get("page") });
      },
      invokeAutoplayEnd({ context, prop }) {
        prop("onAutoplayStatusChange")?.({ type: "autoplay.stop", isPlaying: false, page: context.get("page") });
      }
    }
  }
});
function getPageSnapPoints(totalSlides, slidesPerMove, slidesPerPage) {
  if (totalSlides == null || slidesPerPage <= 0) {
    return [];
  }
  const snapPoints = [];
  const perMove = slidesPerMove === "auto" ? Math.floor(slidesPerPage) : slidesPerMove;
  if (perMove <= 0) {
    return [];
  }
  for (let i = 0; i < totalSlides; i += perMove) {
    if (i + slidesPerPage > totalSlides) break;
    snapPoints.push(i);
  }
  return snapPoints;
}
var props = createProps()([
  "dir",
  "getRootNode",
  "id",
  "ids",
  "loop",
  "page",
  "defaultPage",
  "onPageChange",
  "orientation",
  "slideCount",
  "slidesPerPage",
  "slidesPerMove",
  "spacing",
  "padding",
  "autoplay",
  "allowMouseDrag",
  "inViewThreshold",
  "translations",
  "snapType",
  "autoSize",
  "onDragStatusChange",
  "onAutoplayStatusChange"
]);
var splitProps2 = createSplitProps(props);
var indicatorProps = createProps()(["index", "readOnly"]);
var splitIndicatorProps = createSplitProps(indicatorProps);
var itemProps = createProps()(["index", "snapAlign"]);
var splitItemProps = createSplitProps(itemProps);

// node_modules/@ark-ui/react/dist/components/carousel/carousel.anatomy.js
var carouselAnatomy = anatomy.extendWith("progressText", "autoplayIndicator");

// node_modules/@ark-ui/react/dist/utils/create-context.js
var import_react2 = __toESM(require_react(), 1);
function getErrorMessage(hook, provider) {
  return `${hook} returned \`undefined\`. Seems you forgot to wrap component within ${provider}`;
}
function createContext(options = {}) {
  const {
    name,
    strict = true,
    hookName = "useContext",
    providerName = "Provider",
    errorMessage,
    defaultValue
  } = options;
  const Context = (0, import_react2.createContext)(defaultValue);
  Context.displayName = name;
  function useContext$1() {
    const context = (0, import_react2.useContext)(Context);
    if (!context && strict) {
      const error = new Error(errorMessage ?? getErrorMessage(hookName, providerName));
      error.name = "ContextError";
      if (hasProp(Error, "captureStackTrace") && isFunction(Error.captureStackTrace)) {
        Error.captureStackTrace(error, useContext$1);
      }
      throw error;
    }
    return context;
  }
  return [Context.Provider, useContext$1, Context];
}

// node_modules/@ark-ui/react/dist/components/carousel/use-carousel-context.js
var [CarouselProvider, useCarouselContext] = createContext({
  name: "CarouselContext",
  hookName: "useCarouselContext",
  providerName: "<CarouselProvider />"
});

// node_modules/@ark-ui/react/dist/components/carousel/carousel-autoplay-indicator.js
var parts2 = carouselAnatomy.build();
var CarouselAutoplayIndicator = (0, import_react3.forwardRef)((props2, ref) => {
  const { children, fallback, ...restProps } = props2;
  const carousel = useCarouselContext();
  return (0, import_jsx_runtime.jsx)(ark.span, { ref, ...parts2.autoplayIndicator.attrs, ...restProps, children: carousel.isPlaying ? children : fallback });
});
CarouselAutoplayIndicator.displayName = "CarouselAutoplayIndicator";

// node_modules/@ark-ui/react/dist/components/carousel/carousel-progress-text.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var import_react4 = __toESM(require_react(), 1);
var parts3 = carouselAnatomy.build();
var CarouselProgressText = (0, import_react4.forwardRef)((props2, ref) => {
  const carousel = useCarouselContext();
  const progressText = (0, import_react4.useMemo)(() => {
    const currentPage = carousel.page + 1;
    const totalPages = carousel.pageSnapPoints.length;
    return `${currentPage} / ${totalPages}`;
  }, [carousel.page, carousel.pageSnapPoints.length]);
  return (0, import_jsx_runtime2.jsx)(ark.span, { ref, ...parts3.progressText.attrs, ...props2, children: props2.children || progressText });
});
CarouselProgressText.displayName = "CarouselProgressText";

// node_modules/@ark-ui/react/dist/components/carousel/carousel-autoplay-trigger.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);

// node_modules/@zag-js/react/node_modules/@zag-js/utils/dist/index.mjs
function toArray(v) {
  if (v == null) return [];
  return Array.isArray(v) ? v : [v];
}
var isObjectLike2 = (v) => v != null && typeof v === "object";
var isString2 = (v) => typeof v === "string";
var isFunction2 = (v) => typeof v === "function";
var hasProp2 = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
var baseGetTag = (v) => Object.prototype.toString.call(v);
var fnToString3 = Function.prototype.toString;
var objectCtorString3 = fnToString3.call(Object);
var isPlainObject = (v) => {
  if (!isObjectLike2(v) || baseGetTag(v) != "[object Object]" || isFrameworkElement(v)) return false;
  const proto = Object.getPrototypeOf(v);
  if (proto === null) return true;
  const Ctor = hasProp2(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && fnToString3.call(Ctor) == objectCtorString3;
};
var isReactElement = (x) => typeof x === "object" && x !== null && "$$typeof" in x && "props" in x;
var isVueElement = (x) => typeof x === "object" && x !== null && "__v_isVNode" in x;
var isFrameworkElement = (x) => isReactElement(x) || isVueElement(x);
var identity = (v) => v();
var { floor: floor3, abs: abs3, round: round3, min: min3, max: max3, pow: pow3, sign: sign3 } = Math;
function compact(obj) {
  if (!isPlainObject(obj) || obj === void 0) return obj;
  const keys = Reflect.ownKeys(obj).filter((key) => typeof key === "string");
  const filtered = {};
  for (const key of keys) {
    const value = obj[key];
    if (value !== void 0) {
      filtered[key] = compact(value);
    }
  }
  return filtered;
}
var _tick3;
_tick3 = /* @__PURE__ */ new WeakMap();
function warn(...a) {
  const m = a.length === 1 ? a[0] : a[1];
  const c = a.length === 2 ? a[0] : true;
  if (c && true) {
    console.warn(m);
  }
}
function ensure(c, m) {
  if (c == null) throw new Error(m());
}

// node_modules/@zag-js/react/dist/index.mjs
var React = __toESM(require_react(), 1);
var import_react5 = __toESM(require_react(), 1);
var import_react_dom = __toESM(require_react_dom(), 1);
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var useSafeLayoutEffect = typeof globalThis.document !== "undefined" ? import_react5.useLayoutEffect : import_react5.useEffect;
function useBindable(props2) {
  const initial = props2().value ?? props2().defaultValue;
  const eq = props2().isEqual ?? Object.is;
  const [initialValue] = (0, import_react5.useState)(initial);
  const [value, setValue] = (0, import_react5.useState)(initialValue);
  const controlled = props2().value !== void 0;
  const valueRef = (0, import_react5.useRef)(value);
  valueRef.current = controlled ? props2().value : value;
  const prevValue = (0, import_react5.useRef)(valueRef.current);
  useSafeLayoutEffect(() => {
    prevValue.current = valueRef.current;
  }, [value, props2().value]);
  const setFn = (value2) => {
    const prev = prevValue.current;
    const next = isFunction2(value2) ? value2(prev) : value2;
    if (props2().debug) {
      console.log(`[bindable > ${props2().debug}] setValue`, { next, prev });
    }
    if (!controlled) setValue(next);
    if (!eq(next, prev)) {
      props2().onChange?.(next, prev);
    }
  };
  function get() {
    return controlled ? props2().value : value;
  }
  return {
    initial: initialValue,
    ref: valueRef,
    get,
    set(value2) {
      const exec = props2().sync ? import_react_dom.flushSync : identity;
      exec(() => setFn(value2));
    },
    invoke(nextValue, prevValue2) {
      props2().onChange?.(nextValue, prevValue2);
    },
    hash(value2) {
      return props2().hash?.(value2) ?? String(value2);
    }
  };
}
useBindable.cleanup = (fn) => {
  (0, import_react5.useEffect)(() => fn, []);
};
useBindable.ref = (defaultValue) => {
  const value = (0, import_react5.useRef)(defaultValue);
  return {
    get: () => value.current,
    set: (next) => {
      value.current = next;
    }
  };
};
function useRefs(refs) {
  const ref = (0, import_react5.useRef)(refs);
  return {
    get(key) {
      return ref.current[key];
    },
    set(key, value) {
      ref.current[key] = value;
    }
  };
}
var useTrack = (deps, effect) => {
  const render = (0, import_react5.useRef)(false);
  const called = (0, import_react5.useRef)(false);
  (0, import_react5.useEffect)(() => {
    const mounted = render.current;
    const run = mounted && called.current;
    if (run) return effect();
    called.current = true;
  }, [...(deps ?? []).map((d) => typeof d === "function" ? d() : d)]);
  (0, import_react5.useEffect)(() => {
    render.current = true;
    return () => {
      render.current = false;
    };
  }, []);
};
function useMachine(machine2, userProps = {}) {
  const scope = (0, import_react5.useMemo)(() => {
    const { id, ids, getRootNode } = userProps;
    return createScope({ id, ids, getRootNode });
  }, [userProps]);
  const debug = (...args) => {
    if (machine2.debug) console.log(...args);
  };
  const props2 = machine2.props?.({ props: compact(userProps), scope }) ?? userProps;
  const prop = useProp(props2);
  const context = machine2.context?.({
    prop,
    bindable: useBindable,
    scope,
    flush,
    getContext() {
      return ctx;
    },
    getComputed() {
      return computed;
    },
    getRefs() {
      return refs;
    },
    getEvent() {
      return getEvent();
    }
  });
  const contextRef = useLiveRef(context);
  const ctx = {
    get(key) {
      return contextRef.current?.[key].ref.current;
    },
    set(key, value) {
      contextRef.current?.[key].set(value);
    },
    initial(key) {
      return contextRef.current?.[key].initial;
    },
    hash(key) {
      const current = contextRef.current?.[key].get();
      return contextRef.current?.[key].hash(current);
    }
  };
  const effects = (0, import_react5.useRef)(/* @__PURE__ */ new Map());
  const transitionRef = (0, import_react5.useRef)(null);
  const previousEventRef = (0, import_react5.useRef)(null);
  const eventRef = (0, import_react5.useRef)({ type: "" });
  const getEvent = () => ({
    ...eventRef.current,
    current() {
      return eventRef.current;
    },
    previous() {
      return previousEventRef.current;
    }
  });
  const getState = () => ({
    ...state2,
    matches(...values) {
      return values.includes(state2.ref.current);
    },
    hasTag(tag) {
      return !!machine2.states[state2.ref.current]?.tags?.includes(tag);
    }
  });
  const refs = useRefs(machine2.refs?.({ prop, context: ctx }) ?? {});
  const getParams = () => ({
    state: getState(),
    context: ctx,
    event: getEvent(),
    prop,
    send,
    action,
    guard,
    track: useTrack,
    refs,
    computed,
    flush,
    scope,
    choose
  });
  const action = (keys) => {
    const strs = isFunction2(keys) ? keys(getParams()) : keys;
    if (!strs) return;
    const fns = strs.map((s) => {
      const fn = machine2.implementations?.actions?.[s];
      if (!fn) warn(`[zag-js] No implementation found for action "${JSON.stringify(s)}"`);
      return fn;
    });
    for (const fn of fns) {
      fn?.(getParams());
    }
  };
  const guard = (str) => {
    if (isFunction2(str)) return str(getParams());
    return machine2.implementations?.guards?.[str](getParams());
  };
  const effect = (keys) => {
    const strs = isFunction2(keys) ? keys(getParams()) : keys;
    if (!strs) return;
    const fns = strs.map((s) => {
      const fn = machine2.implementations?.effects?.[s];
      if (!fn) warn(`[zag-js] No implementation found for effect "${JSON.stringify(s)}"`);
      return fn;
    });
    const cleanups = [];
    for (const fn of fns) {
      const cleanup = fn?.(getParams());
      if (cleanup) cleanups.push(cleanup);
    }
    return () => cleanups.forEach((fn) => fn?.());
  };
  const choose = (transitions) => {
    return toArray(transitions).find((t) => {
      let result = !t.guard;
      if (isString2(t.guard)) result = !!guard(t.guard);
      else if (isFunction2(t.guard)) result = t.guard(getParams());
      return result;
    });
  };
  const computed = (key) => {
    ensure(machine2.computed, () => `[zag-js] No computed object found on machine`);
    const fn = machine2.computed[key];
    return fn({
      context: ctx,
      event: getEvent(),
      prop,
      refs,
      scope,
      computed
    });
  };
  const state2 = useBindable(() => ({
    defaultValue: machine2.initialState({ prop }),
    onChange(nextState, prevState) {
      if (prevState) {
        const exitEffects = effects.current.get(prevState);
        exitEffects?.();
        effects.current.delete(prevState);
      }
      if (prevState) {
        action(machine2.states[prevState]?.exit);
      }
      action(transitionRef.current?.actions);
      const cleanup = effect(machine2.states[nextState]?.effects);
      if (cleanup) effects.current.set(nextState, cleanup);
      if (prevState === INIT_STATE) {
        action(machine2.entry);
        const cleanup2 = effect(machine2.effects);
        if (cleanup2) effects.current.set(INIT_STATE, cleanup2);
      }
      action(machine2.states[nextState]?.entry);
    }
  }));
  const hydratedStateRef = (0, import_react5.useRef)(void 0);
  const statusRef = (0, import_react5.useRef)(MachineStatus.NotStarted);
  useSafeLayoutEffect(() => {
    queueMicrotask(() => {
      const started = statusRef.current === MachineStatus.Started;
      statusRef.current = MachineStatus.Started;
      debug(started ? "rehydrating..." : "initializing...");
      const initialState = hydratedStateRef.current ?? state2.initial;
      state2.invoke(initialState, started ? state2.get() : INIT_STATE);
    });
    const fns = effects.current;
    const currentState = state2.ref.current;
    return () => {
      debug("unmounting...");
      hydratedStateRef.current = currentState;
      statusRef.current = MachineStatus.Stopped;
      fns.forEach((fn) => fn?.());
      effects.current = /* @__PURE__ */ new Map();
      transitionRef.current = null;
      queueMicrotask(() => {
        action(machine2.exit);
      });
    };
  }, []);
  const getCurrentState = () => {
    if ("ref" in state2) return state2.ref.current;
    return state2.get();
  };
  const send = (event) => {
    queueMicrotask(() => {
      if (statusRef.current !== MachineStatus.Started) return;
      previousEventRef.current = eventRef.current;
      eventRef.current = event;
      let currentState = getCurrentState();
      const transitions = (
        // @ts-ignore
        machine2.states[currentState].on?.[event.type] ?? // @ts-ignore
        machine2.on?.[event.type]
      );
      const transition = choose(transitions);
      if (!transition) return;
      transitionRef.current = transition;
      const target = transition.target ?? currentState;
      debug("transition", event.type, transition.target || currentState, `(${transition.actions})`);
      const changed = target !== currentState;
      if (changed) {
        (0, import_react_dom.flushSync)(() => state2.set(target));
      } else if (transition.reenter && !changed) {
        state2.invoke(currentState, currentState);
      } else {
        action(transition.actions ?? []);
      }
    });
  };
  machine2.watch?.(getParams());
  return {
    state: getState(),
    send,
    context: ctx,
    prop,
    scope,
    refs,
    computed,
    event: getEvent(),
    getStatus: () => statusRef.current
  };
}
function useLiveRef(value) {
  const ref = (0, import_react5.useRef)(value);
  ref.current = value;
  return ref;
}
function useProp(value) {
  const ref = useLiveRef(value);
  return function get(key) {
    return ref.current[key];
  };
}
function flush(fn) {
  queueMicrotask(() => {
    (0, import_react_dom.flushSync)(() => fn());
  });
}
var normalizeProps = createNormalizer((v) => v);

// node_modules/@ark-ui/react/dist/components/carousel/carousel-autoplay-trigger.js
var import_react7 = __toESM(require_react(), 1);
var CarouselAutoplayTrigger = (0, import_react7.forwardRef)((props2, ref) => {
  const carousel = useCarouselContext();
  const mergedProps = mergeProps(carousel.getAutoplayTriggerProps(), props2);
  return (0, import_jsx_runtime4.jsx)(ark.button, { ...mergedProps, ref });
});
CarouselAutoplayTrigger.displayName = "CarouselAutoplayTrigger";

// node_modules/@ark-ui/react/dist/components/carousel/carousel-context.js
var CarouselContext = (props2) => props2.children(useCarouselContext());

// node_modules/@ark-ui/react/dist/components/carousel/carousel-control.js
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var import_react9 = __toESM(require_react(), 1);
var CarouselControl = (0, import_react9.forwardRef)((props2, ref) => {
  const carousel = useCarouselContext();
  const mergedProps = mergeProps(carousel.getControlProps(), props2);
  return (0, import_jsx_runtime5.jsx)(ark.div, { ...mergedProps, ...props2, ref });
});
CarouselControl.displayName = "CarouselControl";

// node_modules/@ark-ui/react/dist/components/carousel/carousel-indicator.js
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var import_react11 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/utils/create-split-props.js
var createSplitProps2 = () => (props2, keys) => keys.reduce(
  (previousValue, currentValue) => {
    const [target, source] = previousValue;
    const key = currentValue;
    if (source[key] !== void 0) {
      target[key] = source[key];
    }
    delete source[key];
    return [target, source];
  },
  [{}, { ...props2 }]
);

// node_modules/@ark-ui/react/dist/components/carousel/carousel-indicator.js
var splitIndicatorProps2 = createSplitProps2();
var CarouselIndicator = (0, import_react11.forwardRef)((props2, ref) => {
  const [indicatorProps2, localProps] = splitIndicatorProps2(props2, ["readOnly", "index"]);
  const carousel = useCarouselContext();
  const mergedProps = mergeProps(carousel.getIndicatorProps(indicatorProps2), localProps);
  return (0, import_jsx_runtime6.jsx)(ark.button, { ...mergedProps, ref });
});
CarouselIndicator.displayName = "CarouselIndicator";

// node_modules/@ark-ui/react/dist/components/carousel/carousel-indicator-group.js
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var import_react13 = __toESM(require_react(), 1);
var CarouselIndicatorGroup = (0, import_react13.forwardRef)((props2, ref) => {
  const carousel = useCarouselContext();
  const mergedProps = mergeProps(carousel.getIndicatorGroupProps(), props2);
  return (0, import_jsx_runtime7.jsx)(ark.div, { ...mergedProps, ref });
});
CarouselIndicatorGroup.displayName = "CarouselIndicatorGroup";

// node_modules/@ark-ui/react/dist/components/carousel/carousel-item.js
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
var import_react15 = __toESM(require_react(), 1);
var splitItemProps2 = createSplitProps2();
var CarouselItem = (0, import_react15.forwardRef)((props2, ref) => {
  const [itemProps2, localProps] = splitItemProps2(props2, ["index", "snapAlign"]);
  const carousel = useCarouselContext();
  const mergedProps = mergeProps(carousel.getItemProps(itemProps2), localProps);
  return (0, import_jsx_runtime8.jsx)(ark.div, { ...mergedProps, ref });
});
CarouselItem.displayName = "CarouselItem";

// node_modules/@ark-ui/react/dist/components/carousel/carousel-item-group.js
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
var import_react17 = __toESM(require_react(), 1);
var CarouselItemGroup = (0, import_react17.forwardRef)((props2, ref) => {
  const carousel = useCarouselContext();
  const mergedProps = mergeProps(carousel.getItemGroupProps(), props2);
  return (0, import_jsx_runtime9.jsx)(ark.div, { ...mergedProps, ref });
});
CarouselItemGroup.displayName = "CarouselItemGroup";

// node_modules/@ark-ui/react/dist/components/carousel/carousel-next-trigger.js
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
var import_react19 = __toESM(require_react(), 1);
var CarouselNextTrigger = (0, import_react19.forwardRef)((props2, ref) => {
  const carousel = useCarouselContext();
  const mergedProps = mergeProps(carousel.getNextTriggerProps(), props2);
  return (0, import_jsx_runtime10.jsx)(ark.button, { ...mergedProps, ref });
});
CarouselNextTrigger.displayName = "CarouselNextTrigger";

// node_modules/@ark-ui/react/dist/components/carousel/carousel-prev-trigger.js
var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
var import_react21 = __toESM(require_react(), 1);
var CarouselPrevTrigger = (0, import_react21.forwardRef)((props2, ref) => {
  const carousel = useCarouselContext();
  const mergedProps = mergeProps(carousel.getPrevTriggerProps(), props2);
  return (0, import_jsx_runtime11.jsx)(ark.button, { ...mergedProps, ref });
});
CarouselPrevTrigger.displayName = "CarouselPrevTrigger";

// node_modules/@ark-ui/react/dist/components/carousel/carousel-root.js
var import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);
var import_react25 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/carousel/use-carousel.js
var import_react23 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/providers/environment/use-environment-context.js
var [EnvironmentContextProvider, useEnvironmentContext] = createContext({
  name: "EnvironmentContext",
  hookName: "useEnvironmentContext",
  providerName: "<EnvironmentProvider />",
  strict: false,
  defaultValue: {
    getRootNode: () => document,
    getDocument: () => document,
    getWindow: () => window
  }
});

// node_modules/@ark-ui/react/dist/providers/locale/use-locale-context.js
var [LocaleContextProvider, useLocaleContext] = createContext({
  name: "LocaleContext",
  hookName: "useLocaleContext",
  providerName: "<LocaleProvider />",
  strict: false,
  defaultValue: { dir: "ltr", locale: "en-US" }
});

// node_modules/@ark-ui/react/dist/components/carousel/use-carousel.js
var useCarousel = (props2) => {
  const id = (0, import_react23.useId)();
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const machineProps = {
    id,
    dir,
    getRootNode,
    ...props2
  };
  const service = useMachine(machine, machineProps);
  return connect(service, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/carousel/carousel-root.js
var splitRootProps = createSplitProps2();
var CarouselRoot = (0, import_react25.forwardRef)((props2, ref) => {
  const [useCarouselProps, localProps] = splitRootProps(props2, [
    "allowMouseDrag",
    "autoplay",
    "autoSize",
    "defaultPage",
    "id",
    "ids",
    "inViewThreshold",
    "loop",
    "onAutoplayStatusChange",
    "onDragStatusChange",
    "onPageChange",
    "orientation",
    "padding",
    "page",
    "slideCount",
    "slidesPerMove",
    "slidesPerPage",
    "snapType",
    "spacing",
    "translations"
  ]);
  const carousel = useCarousel(useCarouselProps);
  const mergedProps = mergeProps(carousel.getRootProps(), localProps);
  return (0, import_jsx_runtime12.jsx)(CarouselProvider, { value: carousel, children: (0, import_jsx_runtime12.jsx)(ark.div, { ...mergedProps, ref }) });
});
CarouselRoot.displayName = "CarouselRoot";

// node_modules/@ark-ui/react/dist/components/carousel/carousel-root-provider.js
var import_jsx_runtime13 = __toESM(require_jsx_runtime(), 1);
var import_react27 = __toESM(require_react(), 1);
var splitRootProviderProps = createSplitProps2();
var CarouselRootProvider = (0, import_react27.forwardRef)((props2, ref) => {
  const [{ value: carousel }, localProps] = splitRootProviderProps(props2, ["value"]);
  const mergedProps = mergeProps(carousel.getRootProps(), localProps);
  return (0, import_jsx_runtime13.jsx)(CarouselProvider, { value: carousel, children: (0, import_jsx_runtime13.jsx)(ark.div, { ...mergedProps, ref }) });
});
CarouselRootProvider.displayName = "CarouselRootProvider";

// node_modules/@ark-ui/react/dist/components/carousel/carousel.js
var carousel_exports = {};
__export(carousel_exports, {
  AutoplayIndicator: () => CarouselAutoplayIndicator,
  AutoplayTrigger: () => CarouselAutoplayTrigger,
  Context: () => CarouselContext,
  Control: () => CarouselControl,
  Indicator: () => CarouselIndicator,
  IndicatorGroup: () => CarouselIndicatorGroup,
  Item: () => CarouselItem,
  ItemGroup: () => CarouselItemGroup,
  NextTrigger: () => CarouselNextTrigger,
  PrevTrigger: () => CarouselPrevTrigger,
  ProgressText: () => CarouselProgressText,
  Root: () => CarouselRoot,
  RootProvider: () => CarouselRootProvider
});
export {
  carousel_exports as Carousel,
  CarouselAutoplayIndicator,
  CarouselAutoplayTrigger,
  CarouselContext,
  CarouselControl,
  CarouselIndicator,
  CarouselIndicatorGroup,
  CarouselItem,
  CarouselItemGroup,
  CarouselNextTrigger,
  CarouselPrevTrigger,
  CarouselProgressText,
  CarouselRoot,
  CarouselRootProvider,
  carouselAnatomy,
  useCarousel,
  useCarouselContext
};
//# sourceMappingURL=@ark-ui_react_carousel.js.map
